<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
	<!ENTITY % allent SYSTEM "http://www.w3.org/2003/entities/2007/w3centities-f.ent">
	%allent;
]>

<article>
	<articleinfo>
		<title>Simulating the Island Model of Evolutionary Algorithms</title>
		<author>
			<firstname>Kristaps</firstname>
			<surname>Dzonsons</surname>
			<email>kristaps@kcons.eu</email>
		</author>
		<releaseinfo>Version @VERSION@</releaseinfo>
	</articleinfo>
	<sect1 id="intro">
		<title id="intro.title">Introduction</title>
		<para>
			<command>bmigrate</command> is a high-performance scientific application simulating the island model for evolutionary
			algorithms.
			A <firstterm>simulation</firstterm> consists of one or more <firstterm>runs</firstterm>, with each run consisting of a
			finite sequence of <firstterm>generations</firstterm>.
		</para>
		<orderedlist>
			<listitem>
				Initialise a simulation with a fixed number of islands 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
				</inlineequation>, individuals per island
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
				</inlineequation>, migration probability 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
				</inlineequation>, utility function
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
				</inlineequation>, and strategy domain 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>.
			</listitem>
			<listitem>
				Iterate over simulation runs:
				<orderedlist>
					<listitem>
						Initialise all individuals as incumbents, then assign one individual as a mutant.
						Assign a strategy to each individual based on the individual's type, incumbent or mutant.
					</listitem>
					<listitem>
						Iterate over generations:
						<orderedlist>
							<listitem>
								On each island, compute each individual's number of offspring
								(<firstterm>reproduction</firstterm>), which inherit the parent's type.
							</listitem>
							<listitem>
								Assign individuals' offspring to islands (<firstterm>migration</firstterm>).
							</listitem>
							<listitem>
								On each island with immigrants, replace a single inhabitant with a migrant
								(<firstterm>selection</firstterm> and <firstterm>replacement</firstterm>), then
								repeat.
							</listitem>
						</orderedlist>
					</listitem>
					<listitem>
						Terminate the run after a fixed number of generations or when the global mutant or incumbent
						tally reaches zero.
					</listitem>
					<listitem>
						Re-assign the incumbent strategy, mutant strategy, initial mutant's island, then repeat.
					</listitem>
				</orderedlist>
			</listitem>
		</orderedlist>
		<para>
			See <link linkend="notation" endterm="notation.title" /> for a review of the mathematical notation and variable names.
		</para>
		<sect2 id="generations">
			<title id="generations.title">Generations</title>
			<para>
				When a generation begins, each island consists of a non-zero number of individuals of either a mutant or
				incumbent type, each with an assigned type-specific strategy.
				A generation proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Compute an individual's reproductive fertility from a Poisson-distributed random number with mean 
					<inlineequation>
						<alt>&alpha;(1 + &delta;&InvisibleTimes;&pi;)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mi>&pi;</mi>
									<mfenced>
										<msub><mi>x</mi><mi>i</mi></msub>
										<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
									</mfenced>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>, 
					where 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
					</inlineequation>
					is a function accepting the individual's strategy
					<inlineequation>
						<alt>x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation> 
					and all other individuals' strategies
					<inlineequation>
						<alt>x_{-i}</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
						</math>
					</inlineequation> on her island.
					For example, on an island with two individuals having strategies 
					<inlineequation>
						<alt>x = 5</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>x</mi><mo>=</mo><mn>5</mn>
						</math>
					</inlineequation> 
					and
					<inlineequation>
						<alt>y = 2</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>y</mi><mo>=</mo><mn>2</mn>
						</math>
					</inlineequation>,
					with the function simply being
					<inlineequation>
						<alt>x_i + x_{-i}&InvisibleTimes;x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
							<mo>+</mo>
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
							<mo>&InvisibleTimes;</mo>
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation>,
					the first individual's fertility is
					<inlineequation>
						<alt>&alpha;(1 + &delta;15)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>15</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>
					and the second individual's is
					<inlineequation>
						<alt>&alpha;(1 + &delta;12)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>12</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>.
					Since fertility is Poissonian, it is never negative.
				</listitem>
				<listitem>
					Once each individual's offspring count has been computed, the offspring (which inherit the parent's type)
					migrate to other islands.
					With probability
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
					</inlineequation>,
					an offspring will migrate to a randomly-selected other island.
					Otherwise, the offspring will migrate to the parent's (i.e., the current) island.
				</listitem>
				<listitem>
					Lastly, on each island with a queue of individuals migrated from other islands (or the same island), a single
					randomly-selected individual replaces a single randomly-selected individual on the island.
					If an island has no waiting individuals, nothing happens to that island.
				</listitem>
			</orderedlist>
			<para>
				The tally of mutants and incumbents globally and per-island is recomputed following each generation.
			</para>
		</sect2>
		<sect2>
			<title>Runs</title>
			<para>
				A simulation run begins with all individuals but one being incumbents.
				The mutant type is assigned to a single individual in the total population.
				Each individual is assigned a strategy 
				<inlineequation>
					<alt>x_i</alt>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<msub><mi>x</mi><mi>i</mi></msub>
					</math>
				</inlineequation> 
				based on their type.
				A simulation run proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Execute a single generation.
				</listitem>
				<listitem>
					Increment the generation count.
				</listitem>
				<listitem>
					If the generation meets a fixed termination count, stop the run.
					If the global tally of mutants or incumbents reaches zero, stop the run.
					Otherwise, repeat.
				</listitem>
			</orderedlist>
			<para>
				When a simulation run terminates, the fraction of mutants remaining is recorded.
				After accumulating statistics, the run is re-started in its initial configuration with mutant strategy,
				incumbent strategy, and initial mutant island re-assigned.
			</para>
		</sect2>
		<sect2>
			<title>Simulation</title>
			<para>
				Simulations are configured with a number of islands 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
				</inlineequation>,
				individuals per island
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
				</inlineequation>
				(which may be non-uniform), migration probability 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
				</inlineequation>
				(which may be non-uniform and asymmetric), utility function
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
				</inlineequation>, 
				and strategy domain 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>, 
				maximum generation
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
				</inlineequation>, 
				and variables 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&alpha;</mi></mrow></math>
				</inlineequation>, 
				and 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&delta;</mi></mrow></math>
				</inlineequation>
				for transforming utility into the Poisson mean.
				A simulation repeats runs until stopped or paused by the system user.
			</para>
			<para>
				For each run, the incumbent strategy is assigned from a discrete grid over the real-valued strategy domain
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>, 
				The grid's boundaries are inclusive of the domain's lower bound, non-inclusive of the domain's upper bound.
				Thus, if 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<mi>X</mi>
						<mo>&isin;</mo>
						<mfenced open="[" close="]">
							<mn>0</mn>
							<mn>1</mn>
						</mfenced>
					</math>
				</inlineequation>
				and the grid has 100 slots, possible strategies will be 0, 0.01, 0.02, ..., 0.99.
				The mutant strategy may be configured in two ways:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						After each simulation run, the mutant strategy is assigned from the next grid position, e.g.,
						from 0.01 to 0.02.
						If the grid position is at the upper bound, it is re-set to the lower bound.
						The incumbent strategy is only re-assigned when the mutant grid position is re-set to the lower
						bound.
						This behaviour ensures that all mutants and incumbents are treated equally over many simulation
						runs.
					</para>
				</listitem>
				<listitem>
					<para>
						The mutant strategy is assigned from a Gaussian distribution with a preconfigured standard
						deviation and the mean set to the incumbent strategy.
						The strategy is redrawn until it falls within a strategy domain that intersects
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>,
						inclusive of the lower bound, non-inclusive of the upper bound.
						The incumbent strategy is re-assigned when the number of mutants for that incumbent have reached
						the number of slots.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				When the incumbent strategy reaches its upper bound, it resets to the lower bound.
				At this point, the initial mutant island is also incremented.
				The initial mutant island will also wrap when it completes the last island.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Installation</title>
		<para>
			You'll need a UNIX machine to use <command>bmigrate</command>.
			The more powerful your machine, the better:
			<command>bmigrate</command> takes advantage of as many processors as possible.
			It has been compiled and run on <ulink url="https://www.apple.com/osx/">Mac OS X</ulink> Snow
			Leopard (10.6) and later, GNU/Linux (<ulink url="https://www.debian.org/">Debian</ulink>), and <ulink
				url="http://www.openbsd.org">OpenBSD</ulink>.
			In theory, the software may be ported to Microsoft Windows as well, but it's unlikely to happen without external
			contribution.
		</para>
		<sect2>
			<title>Binary Installation</title>
			<para>
				Application binaries are available for Mac OS X Lion (10.7) and later.
				To use these, simply download the ZIP file from the website.
				You may need to configure your system to allow downloaded binaries to run.
			</para>
		</sect2>
		<sect2>
			<title>Source Installation</title>
			<para>
				To compile <command>bmigrate</command>, you'll need a number of dependencies.
				First, you'll need a UNIX machine.
				(If you're running on Mac OS X, just use the binary application: it's a real pain in the neck to configure the
				build system for GTK+3 applications.)
			</para>
			<orderedlist>
				<title>Build dependencies</title>
				<listitem>
					<ulink url="https://www.gnu.org/software/make/">gmake</ulink>: GNU Make, for the build system (the
					default <command>make</command> implementation on Mac OS X and GNU/Linux)
				</listitem>
				<listitem>
					<ulink url="http://www.gtk.org/">GTK+3</ulink>: GNOME Toolkit, for the graphics
				</listitem>
				<listitem>
					<ulink url="https://www.gnu.org/software/gsl/">GSL</ulink>: GNU Scientific Library, for mathematical
					functions
				</listitem>
				<listitem>
					<ulink url="http://www.docbook.org/">DocBook v4.5</ulink>: DocBook-XML, for this documentation
				</listitem>
				<listitem>
					<ulink url="http://libbsd.freedesktop.org/wiki/">libbsd</ulink>: BSD libraries (only relevant for
					GNU/Linux systems)
				</listitem>
			</orderedlist>
			<para>
				These are all available as packages for modern UNIX systems.
				If you're downloading and installing any components on you're own, something is wrong.
			</para>
			<para>
				To compile and install the software, simply run the following.
				(This will use <command>pkg-config</command> to locate relevant GNU tools.)
			</para>
			<screen>
% make
% sudo make install
			</screen>
			<para>
				If you're on a BSD system, you may need to invoke <command>gmake</command> if <command>make</command> defaults
				to the BSD implemenation of the same utility.
			</para>
			<para>
				By default, this will install into <filename>/usr/local</filename>.
				To specify an alternative root, pass the <envar>PREFIX</envar> environment variable to the install command.
				Assuming that <filename>$PREFIX/bin</filename> is in your <envar>PATH</envar>, you can then run the system by
				invoking <command>bmigrate</command>.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Mechanics</title>
		<para>
			Being a high-performance scientific application, <command>bmigrate</command> concerns itself a great deal with mechanics
			such as randomness, parallelism, and data-flow.
			This section briefly touches upon these concepts.
		</para>
		<sect2>
			<title>Data-Flow</title>
			<para>
				Data-flow defines how data moves from simulations to graphed output.
				Having data analysed or graphed directly from simulation data would significantly slow down data collection.
				To minimise simulation and interface stalling, data is copied and translated in several stages.
				In general, data is <firstterm>produced</firstterm> by the simulation threads and
				<firstterm>consumed</firstterm>, periodically and in several stages, by the main graphical thread.
			</para>
			<variablelist>
				<varlistentry>
					<term>Hot Storage</term>
					<listitem>
						<para>
							Statistics (e.g., on-line mutant fractions mean per incumbent) are written directly to
							hot storage by simulation threads.
							<firstterm>Hot</firstterm> refers to the high frequency of data access between the simulation
							threads.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Hot Storage Look-aside Buffer</term>
					<listitem>
						<para>
							When the main graphical thread wishes to read fresh data for graphical display, it sets
							a copy flag to copy-out.
							The first simulation thread to see that this flag has been set to copy-out updates the
							flag to copy-pending and copies the hot storage into a look-aside bufffer.
							Hot storage may then continue to be modified by the simulation threads.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Warm Storage</term>
					<listitem>
						<para>
							After copying data from hot storage into a look-aside buffer, the thread that updated
							the copy flag copies the look-aside buffer into warm storage.
							<firstterm>Warm</firstterm> refers to the low frequency of data access between the main
							graphical thread and the copying simulation thread.
							During the copy, the thread also performs more expensive statistical operations (such as
							minimum mutant fraction, or fitting of data) as it copies the data.
							The thread then clears the copy flag.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Cold Storage</term>
					<listitem>
						<para>
							When the main graphical thread detects that the copy flag has been cleared, it copies
							from warm storage into cold storage.
							<firstterm>Cold</firstterm> means that the data is not changed by anybody but the controlling
							(graphical main) thread.
							The main graphical thread also performs some statistical analysis during the copy.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
			<para>
				This sequence ensures a minimum degree of contention between threads.  
				The main graphical thread needs only to wait for the copy flag to be unset before copying the data into its own
				thread of operation.
				The simulation threads need only wait for the look-aside copy, at which point only one thread is used for
				remaining data copy and statistical analysis.
			</para>
		</sect2>
		<sect2>
			<title>Parallelism</title>
			<para>
				Simulations may be executed in parallel if assigned multiple threads during <link linkend="configuration"
					endterm="configuration.title" />.
				By default, each simulation is assigned a single thread.
				Thus, there are several moments when synchronisation between threads occurs to ensure simulations and data-flow
				processes are race-free with minimum contention.
			</para>
			<itemizedlist>
				<listitem>
					Before each simulation, assignment of incumbent and mutant strategies must be synchronised.
					The index for both of these strategies increases monotonically within a critical section (modulo the
					lattice dimensions).
					For Gaussian-distributed mutants, of course, the mutant monotonicity is irrelevant.
				</listitem>
				<listitem>
					After each simulation, the result for a given incumbent must be tallied in a critical section.
					This is required because, in some situations, a single run might take long enough that another processor
					starts running with the same incumbent, with both finishing simultaneously.
				</listitem>
				<listitem>
					When data is copied from hot storage into the look-aside buffer, it is copied within a critical section.
					This prevents partial modification to the data in-copy.
				</listitem>
				<listitem>
					When the main graphical thread requests a data copyout, it does so in a critical section.
					This ensures that only a single simulation thread will perform the copyout, and also that the main
					calling thread won't have its copyout flag unset before all data has been copied.
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Randomness</title>
			<para>
				By default, <command>bmigrate</command> uses the MT19937 (Mersenne-Twister) generator of
				<citation>matsumoto98</citation>.
				This ensures good-quality randomness with a very high period.
				(There is currently no facility in <command>bmigrate</command> for handlng period roll-over.)
			</para>
			<para>
				Each simulation thread is allocated its own randomn number generator.
				Each generator is assigned seed from <function>arc4random</function>, which is implemented differently across
				operating systems.
				This ensures that all threads produce independent random variables.
			</para>
		</sect2>
		<sect2>
			<title>Precision</title>
			<para>
				All floating-point operations of <command>bmigrate</command> use double-precision (type <type>double</type>)
				floating point numbers.
				The statistical algorithms used (see links to algorithm descriptions) provide robust numerical stability.
			</para>
			<para>
				Integral operations (counters) use unsigned 64-bit integers (type <type>uint64_t</type>).
				No checking is done for additive or multiplicative overflow as a simulation with more than
				<inlineequation>
					<alt>2^64</alt>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<msup>
							<mn>2</mn>
							<mn>64</mn>
						</msup>
					</math>
				</inlineequation>
				runs is pretty unlikely.
			</para>
		</sect2>
	</sect1>
	<sect1 id="configuration">
		<title id="configuration.title">Configuration</title>
		<para>
			When invoked, <command>bmigrate</command> will pop up a configuration screen.
			You use this to configure and deploy simulations.
			To quit the system, simply press <guibutton>Quit</guibutton>.
			To start a simulation (after entering configuration data), press <guibutton>Simulate</guibutton>.
			The configuration screen will remain open so that you can start subsequent simulations.
		</para>
		<screenshot>
			<graphic fileref="screen-config.png" />
		</screenshot>
		<para>
			Begin by assigning 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
			</inlineequation>, 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
			</inlineequation>,
			and 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
			</inlineequation>.
			This constitutes the environment structure of the game; or in other words, the physical layout of the islands.
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
			</inlineequation>
			and so on.
		</para>
		<variablelist>
			<title>Environment Structure</title>
			<varlistentry>
				<term>Uniform</term>
				<listitem>
					<para>
						The simplest configuration of a fixed number of islands 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
						</inlineequation>;
						a fixed,
						uniform number of individuals per island 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
						</inlineequation>;
						and a probability
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
						</inlineequation>
						of inter-island migration uniform to all [other] islands.
						The default is 100 individuals across 50 islands.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Variable</term>
				<listitem>
					<para>
						Non-uniform individuals per island.
						There must be at least two individuals per island.
						The probability 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
						</inlineequation>
						of inter-island migration must also be applied.
						If you specify an equal number of islanders for all islands, this will revert to the Uniform
						configuration.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mapped</term>
				<listitem>
					<para>
						Non-uniform inter-island migration and non-uniform population sizes.  It accepts a <ulink
							url="http://www.opengeospatial.org/standards/kml/">KML</ulink> map file populated with
						two or more <code>Placemark</code> sections with appropriate <code>coordinates</code>.
						Inter-island migration is then computed as either the normalised inverse-square distance between
						each island or uniform random (i.e., the same as that of the Variable or Uniform configuration).
						See <link linkend="mapping" endterm="mapping.title" /> for details.
					</para>
					<para>
						Normalised means that, for each island, the inverse-square distance is computed to all other
						islands.  
						These values are then divided by the sum of all so that each pair of islands is associated with
						a probability.
					</para>
					<para>
						The initial island population defaults to two unless the string <code>@@population=N@@</code>
						is specified somewhere in the KML text portion within an island's <code>Placemark</code> section.
						The value <code>N</code> must be strictly greater than one.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Next, configure the utility function 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
			</inlineequation>,
			which dictates the reproduction of individuals.
			Note that the utility function is not provided directly to the Poisson generator, but is linearly transformed as
			described in <link linkend="generations" endterm="generations.title" />.
		</para>
		<variablelist>
			<title>Game Configuration</title>
			<varlistentry>
				<term>Continuum</term>
				<listitem>
					<para>
						Configure a utility function accepting individuals' strategies.
						You can either select a preset function or provide one yourself.
					</para>
					<para>
						The utility function 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
						</inlineequation>
						accepts the current individual's strategy
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>
						</inlineequation>,
						the sum of all other individuals' strategies
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>
						on the individual's island, and the number of individuals
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
						</inlineequation>
						on the individual's island.  The function accepts basic binary and
						unary arithmetic operations, nested expressions, the 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>exp</mo></mrow></math>
						</inlineequation>
						function, the
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>sqrt</mo></mrow></math>
						</inlineequation>
						function, and double-precision numbers.
					</para>
					<para>
						You can also change the strategy domain for the incumbent's strategy, which is inclusive of the
						lower bound, non-inclusive of the upper bound.
						(The mutant's strategy domain is applied elsewhere.)
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Lastly, configure the process machinery itself.
			This involves both the machinery itself and how it relates to hardware (parallelism) and also how payoffs are
			normalised.
		</para>
		<variablelist>
			<title>Process Configuration</title>
			<varlistentry>
				<term>Threads</term>
				<listitem>
					<para>
						The number of threads of execution.
						The maximum number of threads is the number of processors (or cores) of your system.
						You should plan your simulations so as not to oversubscribe your machine, e.g., if you're
						running 4 simulations on a 64-processor machine, you should allocate 16 threads per simulation.
						(This assumes that each simulation is equally time-consuming.)
						Assume that each thread will consume 100% of processor or core resources.
					</para>
					<para>
						The number of reserved threads is the sum of all threads for simulations, regardless of state;
						running threads show only the count of non-paused simulations.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Max Generations</term>
				<listitem>
					<para>
						The maximum number of generations per simulation run.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Parameters</term>
				<listitem>
					<para>
						The linear transform from utility function to Poisson process mean.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Incumbents</term>
				<listitem>
					<para>
						This sets how finely the strategy domain is sliced for assigning incumbents and mutants to
						discrete strategies.
						For example, if this value is 100 (the default), then a strategy domain in the unit interval
						results in strategies of 0, 0.01, 0.02, ..., 0.99.
						A higher number will make a finer mesh, but take more time to process.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mutants</term>
				<listitem>
					<para>
						Determines how mutants are assigned.
						If discrete, mutants are assigned in sequence from the incumbent grid.
						If Gaussian, mutants are assigned from a Gaussian distribution around the incumbent strategy
						with the given standard deviation.
						The distribution is truncated to the given strategy domain, inclusive of its lower bound,
						non-inclusive of the upper bound.
						This strategy domain must be a superset of the incumbent domain 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>
						The Box-Muller algorithm is used for producing Gaussian-distributed random numbers.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Fit polynomial</term>
				<listitem>
					<para>
						If you wish to fit incumbents' mean mutant fraction to a polynomial during run-time, you may
						specify the degree of that polynomial here.
						If set to 0, fitting will not be performed.
						If set to non-zero, you may also specify that the fitting be weighed by the variance of each
						incumbent mean mutant fraction.
						The fitting algorithm is the modified Golub-Reinsch SVD algorithm with column scaling.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Name</term>
				<listitem>
					<para>
						A free-form name for the simulation.
						Defaults to the current time.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</sect1>
	<sect1>
		<title>Visualisation</title>
		<para>
			When you've configured a simulation, press <guibutton>Simulate</guibutton> to start the visualisation.
			If all values validate, a window will pop up visualising the simulation in a variety of ways.
			If values don't validate, they'll be noted and you can fix them.
			Each field must be properly filled in before the simulation begins.
			Don't worry&mdash;you'll be able to review each configuration element while a simulation is running.
		</para>
		<para>
			Simulations are reference-counted: when you start a simulation, it has a single referring window.
			Each window visualises at least one simulation: to compare different simulations, you can drag and drop simulation
			windows into each other.
			This will increase the reference to individual simulations.
			The same happens if you clone a view.
			When you close a window, each simulation is dereferenced.
			When no windows reference a simulation, it will terminate.
		</para>
		<sect2>
			<title>Control</title>
			<para>
				Simulation and analyses are controlled from the menu bar in Mac OS X or in a pop-up menu on other UNIX machines.
				Simulations are controlled with the <guimenu>Tools</guimenu> and <guimenu>File</guimenu> menu.
				Analysis is controlled with the <guimenu>View</guimenu> menu.
			</para>
			<sect3>
				<title>File</title>
				<para>
					You can perform the usual <guimenuitem>Quit</guimenuitem> and <guimenuitem>Close</guimenuitem>
					operations (the latter will dereference each simulation, just like closing the window by way of your
					window manager).
					You can also <guimenuitem>Clone</guimenuitem> your view, which will duplicate the window (including all
					simulations).
					You can also save a windows's current view of its simulations as a data file (described in each <link
						linkend="views" endterm="views.title" />).
					You can export all views of all simulations into a folder as well, or (for the time being, only if
					provided a map on configuration) the KML representation of each simulation into a folder (described in
					<link linkend="mapping" endterm="mapping.title" />).
				</para>
			</sect3>
			<sect3>
				<title>View</title>
				<para>
					Switch the current view, which consists of one or more simulations, to another.
					These are listed in <link linkend="views" endterm="views.title" />.
				</para>
			</sect3>
			<sect3>
				<title>Tools</title>
				<para>
					From here you can pause or unpause simulations.
					These apply to all simulations in the current window.
					You can also register a directory into which all views will be auto-exported once per minute.
					(This is handy when running extensive simulations over an iffy network.)
				</para>
			</sect3>
		</sect2>
		<sect2 id="views">
			<title id="views.title">Views</title>
			<para>
				Each window may have an arbitrary number of simulations and is connected to a particular view of those
				simulations.
				You can choose a new view from the <guimenu>View</guimenu> menu.
				The current view is reflected in the window's title bar.
			</para>
			<sect3 id="samplemean">
				<title id="samplemean.title">Sample Mean</title>
				<para>
					The sample mean graphs incumbent strategies on the x-axis and the mean mutant fraction after
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>
					generations (or when one of the types goes extinct&mdash;whichever comes
					first) over all runs to date on the y-axis.
					If an incumbent does not have any runs yet, it will display as zero.
					The graph y-maximum will automatically adjust to the highest simulation peak.
				</para>
				<para>
					Each simulation is shown in the legend below the graph.
					The legend shows the simulation colour and name, as well as the number of runs involved in constructing
					the mean.
				</para>
			</sect3>
			<sect3 id="samplemeansigma">
				<title id="samplemeansigma.title">Sample Mean and Sigma</title>
				<para>
					This graph augments the <link linkend="samplemean" endterm="samplemean.title" /> graph with the standard
					deviation above and below each incumbent's mean.
					The standard deviation below is truncated to zero when negative.
				</para>
				<para>
					The standard deviation is computed from the unbiased sample variance algorithm of
					<citation>knuth98</citation>.
					It shouldn't be confused with the population standard deviation, which is computed over all
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math>
					</inlineequation>
					samples (simulation runs).
					This is an unbiased estimate computed over 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t-1</mi></mrow></math>
					</inlineequation>
					samples.
					See <citation>knuth98</citation> and <citation>welford62</citation> for a discussion.
				</para>
			</sect3>
			<sect3 id="samplemeanfitted">
				<title id="samplemeanfitted.title">Sample Mean and Fitted Polynomial</title>
				<para>
					If a non-zero degree for polynomial fitting was selected at <link linkend="configuration"
						endterm="configuration.title" />, this will show the <link linkend="samplemean"
						endterm="samplemean.title" /> along with that polynomial.
					Otherwise it will only show the <link linkend="samplemean" endterm="samplemean.title" />.
					If the weighted option was selected during <link linkend="configuration" endterm="configuration.title"
						/>, the incumbents' standard deviation will be used as a weight.
				</para>
				<para>
					Unlike the <link linkend="samplemean" endterm="samplemean.title" /> or <link linkend="samplemeansigma"
						endterm="samplemeansigma.title" />, the data for this graph is computed roughly four times per
					second instead of with every run.
					This prevents excessive slow-down.
					The implementations are <function>gsl_multifit_wlinear</function> and
					<function>gsl_multifit_linear</function> for the weighted and non-weighted fitting algorithm,
					respectively, of the <ulink url="https://www.gnu.org/software/gsl/">GNU Scientific Library</ulink>.
					Both are described in the Statistics chapter of <citation>barnett96</citation>.
				</para>
			</sect3>
			<sect3 id="mutantextinctions">
				<title id="mutantextinctions.title">Mutant Extinctions</title>
				<para>
					The percentage of simulation runs to date of each incumbent where the mutant population goes extinct
					before the maximum simulation time
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>.
					The x-axis shows incumbent strategy.
					The y-axis shows the fraction of mutant extinctions in the unit interval.
					If the incumbent does not yet have any data (i.e., no runs yet), it shows zero.
				</para>
			</sect3>
			<sect3 id="incumbentextinctions">
				<title id="incumbentextinctions.title">Incumbent Extinctions</title>
				<para>
					The percentage of simulation runs to date of each incumbent where the incumbent population goes extinct
					before the maximum simulation time
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>.
					The x-axis shows incumbent strategy.
					The y-axis shows the fraction of incumbent extinctions in the unit interval.
					If the incumbent does not yet have any data (i.e., no runs yet), it shows zero.
				</para>
			</sect3>
			<sect3 id="smoothedsamplemean">
				<title id="smoothedsamplemean.title">Smoothed Sample Mean</title>
				<para>
					This is the same as <link linkend="samplemean" endterm="samplemean.title" /> except with the data points
					(sample mean per incumbent strategy on the x-axis) smoothed by a moving average.
				</para>
				<para>
					The moving average is computed for each interior point by replacing the current point with the average
					of the prior and subsequent point.
					The border points (first and last strategy) are not adjusted.
					The moving average is not cascading: when replacing points, the prior and subsequent point used for
					averaging are from the original data set, not the smoothed data set.
				</para>
			</sect3>
			<sect3>
				<title>Smoothed Mutant Extinctions</title>
				<para>
					This is the same as <link linkend="mutantextinctions" endterm="mutantextinctions.title" /> except with
					the data points (extinction fraction per incumbent strategy on the x-axis) smoothed by a moving average.
					See <link linkend="smoothedsamplemean" endterm="smoothedsamplemean.title" /> for the moving average
					calculation.
				</para>
			</sect3>
			<sect3 id="fittedpolyminpdf">
				<title id="fittedpolyminpdf.title">Fitted Polynomial Minimum (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemeanfitted" endterm="samplemeanfitted.title" />
					into an empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
				</para>
				<para>
					The minimum value is the first minimum: if multiple subsequent minima are detected (a basin), they are
					ignored.
					This might skew values toward smaller minima.
					Minima are accumulated four times per second, not for each simulation run.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial Minimum (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemeanfitted" endterm="samplemeanfitted.title" />
					into an empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3 id="samplemeanminpdf">
				<title id="samplemeanminpdf.title">Sample Mean Minimum (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemean" endterm="samplemean.title" /> into an
					empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3>
				<title>Sample Mean Minimum (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemean" endterm="samplemean.title" /> into an
					empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3 id="mutantextinctionminpdf">
				<title id="mutantextinctionminpdf.title">Mutant Extinctions Minimum (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="mutantextinctions" endterm="mutantextinctions.title" />
					into an empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3>
				<title>Mutant Extinctions Minimum (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="mutantextinctions" endterm="mutantextinctions.title" />
					into an empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3 id="incumbentextinctionminpdf">
				<title id="incumbentextinctionminpdf.title">Incumbent Extinctions Minimum (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="incumbentextinctions"
						endterm="incumbentextinctions.title" /> into an empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3>
				<title>Incumbent Extinctions Minimum (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="incumbentextinctions"
						endterm="incumbentextinctions.title" /> into an empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3 id="smoothedsamplemeanminpdf">
				<title id="smoothedsamplemeanminpdf.title">Smoothed Sample Mean Minimum (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="smoothedsamplemean" endterm="smoothedsamplemean.title" />
					into an empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3>
				<title>Smoothed Sample Mean Minimum (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="smoothedsamplemean" endterm="smoothedsamplemean.title" />
					into an empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
					See <link linkend="fittedpolyminpdf" endterm="fittedpolyminpdf.title" /> for details on computing the
					distribution.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial Minimum History</title>
				<para>
					Accumulate the last 256 instantaneous minimum values (approximately the last minute) of <link
						linkend="samplemeanfitted" endterm="samplemeanfitted.title" />.
					The mean and mode are also drawn as solid and dashed horizontal lines, respectively.
				</para>
			</sect3>
			<sect3>
				<title>Sample Mean Minimum History</title>
				<para>
					Accumulate the last 256 instantaneous minimum values (approximately the last minute) of <link
						linkend="samplemeanminpdf" endterm="samplemeanminpdf.title" />.
					The mean and mode are also drawn as solid and dashed horizontal lines, respectively.
				</para>
			</sect3>
			<sect3>
				<title>Smoothed Sample Mean Minimum History</title>
				<para>
					Accumulate the last 256 instantaneous minimum values (approximately the last minute) of <link
						linkend="smoothedsamplemeanminpdf" endterm="smoothedsamplemeanminpdf.title" />.
					The mean and mode are also drawn as solid and dashed horizontal lines, respectively.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial Minimum Mean</title>
				<para>
					Plot the incumbent strategy distribution mean of <link linkend="fittedpolyminpdf"
						endterm="fittedpolyminpdf.title" /> within the standard deviation error bars.
					Each simulation is plotted as a separate point.
				</para>
			</sect3>
			<sect3>
				<title>Sample Mean Minimum Mean</title>
				<para>
					Plot the incumbent strategy distribution mean of <link linkend="samplemeanminpdf"
						endterm="samplemeanminpdf.title" /> within the standard deviation error bars.
					Each simulation is plotted as a separate point.
				</para>
			</sect3>
			<sect3>
				<title>Mutant Extinctions Minimum Mean</title>
				<para>
					Plot the incumbent strategy distribution mean of <link linkend="mutantextinctionminpdf"
						endterm="mutantextinctionminpdf.title" /> within the standard deviation error bars.
					Each simulation is plotted as a separate point.
				</para>
			</sect3>
			<sect3>
				<title>Incumbent Extinctions Minimum Mean</title>
				<para>
					Plot the incumbent strategy distribution mean of <link linkend="incumbentextinctionminpdf"
						endterm="incumbentextinctionminpdf.title" /> within the standard deviation error bars.
					Each simulation is plotted as a separate point.
				</para>
			</sect3>
			<sect3>
				<title>Smoothed Sample Mean Minimum Mean</title>
				<para>
					Plot the incumbent strategy distribution mean of <link linkend="smoothedsamplemeanminpdf"
						endterm="smoothedsamplemeanminpdf.title" /> within the standard deviation error bars.
					Each simulation is plotted as a separate point.
				</para>
			</sect3>
			<sect3>
				<title>Island Sample Mean and Sigma</title>
				<para>
					For each island where the mutant is assigned at the simulation run start, print the mean mutant fraction
					after 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>
					generations (or when one of the types goes extinct&mdash;whichever comes first) over all runs to date.
					In other words, accumulate, given an island, how robustly a starting mutant behaves.
				</para>
			</sect3>
			<sect3>
				<title>Configuration</title>
				<para>
					Print the configuration of each simulation in a window as set during <link linkend="configuration"
						endterm="configuration.title" />.
				</para>
			</sect3>
			<sect3>
				<title>Status</title>
				<para>
					Print the running status (number of simulation runs, generations, etc.) of each simulation.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="mapping">
		<title id="mapping.title">Mapping</title>
		<para>
			<command>bmigrate</command> has extensive support for extracting population structures from maps, specifically from and
			to <ulink url="http://www.opengeospatial.org/standards/kml/">KML</ulink> map files.
			A common way of creating and manipulating KML files is with <ulink url="https://www.google.com/earth/">Google
				Earth</ulink>.
		</para>
		<para>
			During <link linkend="configuration" endterm="configuration.title" />, one can provide a map file from which population
			sizes and inter-island migration probabilities are computed.
			Each island corresponds to a KML <code>Placemark</code>.
			The coordinates of the island are extracted from its <code>coordinates</code> tuple.
			Lastly, if the string <code>@@population=NNN@@</code> appears in any text segment within the <code>Placemark</code>
			(e.g., within the <code>Description</code>), the <code>NNN</code> will be used as the island's population.
			If it isn't a valid number, it will raise an error.
			The default island population is 2.
		</para>
		<para>
			One can also save map files (as a directory of KML files, accomodating for multiple simulations).
			If a map was provided during configuration, the same map file is outputted, but certain key words will be replaced by
			the simulation statistics:
		</para>
		<variablelist>
			<varlistentry>
				<term><code>@@mean@@</code></term>
				<listitem>
					The mean mutant fraction over all simulation runs when the mutant is initialised
					on the given island.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><code>@@meanpct@@</code></term>
				<listitem>
					Like <code>@@mean@@</code>, but normalised as a percentage of all islands' accumulated fraction.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><code>@@population@@</code> or <code>@@population=NNN@@</code></term>
				<listitem>
					The island population.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><code>@@stddev@@</code></term>
				<listitem>
					The standard deviation of the mean mutant fraction over all simulation runs when the mutant is
					initialised on the given island.
				</listitem>
			</varlistentry>
		</variablelist>
	</sect1>
	<sect1 id="notation">
		<title id="notation.title">Notation</title>
		<para>
			The following notation is used consistently throughout this document and the system itself.
		</para>
		<variablelist>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&alpha;</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					The outer multiplier for the linear transform of the utility function,
					<inlineequation>
						<alt>&alpha;(1 + &delta;&InvisibleTimes;&pi;)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mi>&pi;</mi>
									<mfenced>
										<msub><mi>x</mi><mi>i</mi></msub>
										<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
									</mfenced>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&delta;</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					The inner multiplier for the linear transform of the utility function,
					<inlineequation>
						<alt>&alpha;(1 + &delta;&InvisibleTimes;&pi;)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mi>&pi;</mi>
									<mfenced>
										<msub><mi>x</mi><mi>i</mi></msub>
										<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
									</mfenced>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					For each offspring, the probability of migration.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
					</inlineequation>,
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mrow><msub><mi>n</mi><mi>i</mi></msub></mrow>
						</math>
					</inlineequation>
				</term>
				<listitem>
					The number of individuals per island
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>&ge;</mo><mn>2</mn></mrow></math>
					</inlineequation>.
					If the islands have a uniform population size, then this number is constant; otherwise, it may be
					non-uniform
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow></math>
					</inlineequation>
					where
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi></mrow></math>
					</inlineequation>
					is the fixed index of an island.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					The total number of islands
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>&ge;</mo><mn>2</mn></mrow></math>
					</inlineequation>.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					The payoff function.
					This accepts three variables:
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>
					</inlineequation>,
					the strategy of the current individual;
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
					</inlineequation>,
					the sum of all individuals' strategies; and
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
					</inlineequation>,
					the number of individuals.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>
				</term>
				<listitem>
					The maximum number of generations 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi><mo>&ge;</mo><mn>1</mn></mrow></math>
					</inlineequation>
					for which a simulation run will run.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
					</inlineequation>,
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>
					</inlineequation>,
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mrow><msub><mi>x</mi><mi>i</mi></msub></mrow>
						</math>
					</inlineequation>,
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mrow><msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub></mrow>
						</math>
					</inlineequation>
				</term>
				<listitem>
					The real-valued strategy domain, a single strategy in that domain, an individual 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi></mrow></math>
					</inlineequation>'s 
					strategy, and all other individuals' strategies.
				</listitem>
			</varlistentry>
		</variablelist>
	</sect1>
	<bibliography>
		<title>Bibliography</title>
		<biblioentry>
			<abbrev>knuth98</abbrev>
			<authorgroup>
				<author>
					<firstname>Donald E.</firstname>
					<surname>Knuth</surname>
				</author>
			</authorgroup>
			<pubdate>1998</pubdate>
			<publisher>
				<publishername>Addison-Wesley Publishing Company</publishername>
				<address><city>Boston</city></address>
			</publisher>
			<title>The Art of Computer Programming</title>
			<volumenum>Volume 2</volumenum>
			<subtitle>Seminumerical Algorithms</subtitle>
			<pagenums>232</pagenums>
			<edition>3rd edition</edition>
		</biblioentry>
		<biblioentry>
			<abbrev>welford62</abbrev>
			<author>
				<firstname>B. P.</firstname>
				<surname>Welford</surname>
			</author>
			<pubdate>1962</pubdate>
			<publishername>Technometrics</publishername>
			<issuenum>Number 3</issuenum>
			<volumenum>Volume 4</volumenum>
			<pagenums>419-420</pagenums>
		</biblioentry>
		<biblioentry>
			<abbrev>barnett96</abbrev>
			<editor>
				<firstname>R. M.</firstname>
				<surname>Barnett</surname>
			</editor>
			<pubdate>1996</pubdate>
			<publisher>
				<publishername>Particle Data Group (PDG)</publishername>
			</publisher>
			<title>The Review of Particle Physics D.54</title>
		</biblioentry>
		<biblioentry>
			<abbrev>matsumoto98</abbrev>
			<authorgroup>
				<author>
					<firstname>Makato</firstname>
					<surname>Matsumoto</surname>
				</author>
				<author>
					<firstname>Takuji</firstname>
					<surname>Nishimura</surname>
				</author>
			</authorgroup>
			<title>Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudorandom Number Generator</title>
			<publishername>ACM Transactions on Modeling and Computer Simulation</publishername>
			<volumenum>Volume 8</volumenum>
			<issuenum>Number 1</issuenum>
			<pubdate>January 1998</pubdate>
			<pagenums>3-30</pagenums>
		</biblioentry>
	</bibliography>
</article>
