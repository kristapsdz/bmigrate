<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article [
	<!ENTITY % allent SYSTEM "http://www.w3.org/2003/entities/2007/w3centities-f.ent">
	%allent;
]>
<article xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:mml="http://www.w3.org/1998/Math/MathML" xml:lang="en">
	<articleinfo>
		<title>Simulating the Island Model of Evolutionary Algorithms</title>
		<author>
			<firstname>Kristaps</firstname>
			<surname>Dzonsons</surname>
			<email>kristaps@kcons.eu</email>
		</author>
		<releaseinfo>Version @VERSION@</releaseinfo>
	</articleinfo>
	<sect1>
		<title>Introduction</title>
		<para>
			<command>bmigrate</command> is a high-performance scientific application simulating the island model for
			evolutionary algorithms.
			A <firstterm>simulation</firstterm> consists of one or more <firstterm>runs</firstterm>, with each run consisting of a
			finite sequence of <firstterm>generations</firstterm>.
		</para>
		<orderedlist>
			<listitem>
				Initialise a simulation with a fixed number of islands <mathphrase>N</mathphrase>, individuals per island
				<mathphrase>n</mathphrase>, migration probability <mathphrase>m</mathphrase>, utility function
				<mathphrase>&pi;</mathphrase>, and strategy domain <mathphrase>X</mathphrase>.
			</listitem>
			<listitem>
				Iterate over simulation runs:
				<orderedlist>
					<listitem>
						Initialise all individuals as incumbents, then assign one individual as a mutant.
						Assign a strategy to each individual based on the individual's type, incumbent or mutant.
					</listitem>
					<listitem>
						Iterate over generations:
						<orderedlist>
							<listitem>
								On each island, compute each individual's number of offspring
								(<firstterm>reproduction</firstterm>), which inherit the parent's type.
							</listitem>
							<listitem>
								Assign individuals' offspring to islands (<firstterm>migration</firstterm>).
							</listitem>
							<listitem>
								On each island, replace a single inhabitant with a migrant (<firstterm>selection</firstterm> and
								<firstterm>replacement</firstterm>), then repeat.
							</listitem>
						</orderedlist>
					</listitem>
					<listitem>
						Terminate the run after a fixed number of generations or when the global mutant or incumbent tally reaches zero.
					</listitem>
					<listitem>
						Re-assign the incumbent and mutant strategies, then repeat.
					</listitem>
				</orderedlist>
			</listitem>
		</orderedlist>
		<para>
			The following sub-sections define specific behaviour.
		</para>
		<sect2>
			<title>Generations</title>
			<para>
				When a generation begins, each island consists of a non-zero number of individuals of either a mutant or
				incumbent type, each with an assigned type-specific strategy.
				A generation proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Compute an individual's reproductive fertility from a Poisson-distributed random number with mean 
					<inlineequation>
						<alt>&alpha;(1 + &delta;&InvisibleTimes;&pi;)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mi>&pi;</mi>
									<mfenced>
										<msub><mi>x</mi><mi>i</mi></msub>
										<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
									</mfenced>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>, 
					where 
					<mathphrase>&pi;</mathphrase>
					is a function accepting the individual's strategy
					<inlineequation>
						<alt>x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation> 
					and all other individuals' strategies
					<inlineequation>
						<alt>x_{-i}</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
						</math>
					</inlineequation> on her island.
					For example, on an island with two individuals having strategies 
					<inlineequation>
						<alt>x = 5</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>x</mi><mo>=</mo><mn>5</mn>
						</math>
					</inlineequation> 
					and
					<inlineequation>
						<alt>y = 2</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>y</mi><mo>=</mo><mn>2</mn>
						</math>
					</inlineequation>,
					with the function simply being
					<inlineequation>
						<alt>x_i + x_{-i}&InvisibleTimes;x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
							<mo>+</mo>
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
							<mo>&InvisibleTimes;</mo>
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation>,
					the first individual's fertility is
					<inlineequation>
						<alt>&alpha;(1 + &delta;15)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>15</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>
					and the second individual's is
					<inlineequation>
						<alt>&alpha;(1 + &delta;12)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>12</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>.
				</listitem>
				<listitem>
					Once each individual's offspring count has been computed, the offspring (which inherit the parent's type)
					migrate to other islands.
					With probability <mathphrase>m</mathphrase>,
					an offspring will migrate to a randomly-selected other island.
					Otherwise, the offspring will migrate to the parent's (i.e., the current) island.
				</listitem>
				<listitem>
					Lastly, on each island with a queue of individuals migrated from other islands (or the same island), a single
					randomly-selected individual replaces a single randomly-selected individual on the island.
				</listitem>
			</orderedlist>
			<para>
				The tally of mutants and incumbents globally and per-island is recomputed following each generation.
			</para>
		</sect2>
		<sect2>
			<title>Runs</title>
			<para>
				A simulation run begins with all individuals but one being incumbents.
				The mutant type is assigned to a random individual in the total population.
				Each individual is assigned a strategy 
				<inlineequation>
					<alt>x_i</alt>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<msub><mi>x</mi><mi>i</mi></msub>
					</math>
				</inlineequation> 
				based on their type.
				A simulation run proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Execute a single generation.
				</listitem>
				<listitem>
					Increment the generation count.
				</listitem>
				<listitem>
					If the generation meets a fixed termination count, stop the run.
					If the global tally of mutants or incumbents reaches zero, stop the run.
					Otherwise, repeat.
				</listitem>
			</orderedlist>
			<para>
				When a simulation run terminates, the fraction of mutants remaining is accumulated and the sample mean, standard
				deviation, kurtosis, skewness, and variance are recorded.
				The statistical algorithm is from Knuth/Welford.
			</para>
			<para>
				After accumulating statistics, the run is re-started in its initial configuration with mutant and incumbent
				strategy re-assigned.
			</para>
		</sect2>
		<sect2>
			<title>Simulation</title>
			<para>
				Simulations are configured with a number of islands <mathphrase>N</mathphrase>, individuals per island
				<mathphrase>n</mathphrase>, migration probability <mathphrase>m</mathphrase>, utility function
				<mathphrase>&pi;</mathphrase>, and strategy domain <mathphrase>X</mathphrase>, maximum generation
				<mathphrase>T</mathphrase>, and variables <mathphrase>&alpha;</mathphrase> and <mathphrase>&delta;</mathphrase>
				for transforming utility into the Poisson mean.
				A simulation repeats runs until stopped or paused by the system user.
			</para>
			<para>
				For each run, the incumbent strategy is assigned from a discrete grid over the real-valued strategy domain
				<mathphrase>X</mathphrase>.
				The grid's boundaries are inclusive of the domain's lower bound, non-inclusive of the domain's upper bound.
				Thus, if 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<mi>X</mi>
						<mo>&isin;</mo>
						<mfenced open="[" close="]">
							<mn>0</mn>
							<mn>1</mn>
						</mfenced>
					</math>
				</inlineequation>
				and the grid has 100 slots, possible strategies will be 0, 0.01, 0.02, ..., 0.99.
				The mutant strategy may be configured in two ways:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						After each simulation run, the mutant strategy is assigned from the next grid position, e.g.,
						from 0.01 to 0.02.
						If the grid position is at the upper bound, it is re-set to the lower bound.
						The incumbent strategy is only re-assigned when the mutant grid position is re-set to the lower
						bound.
						This behaviour ensures that all mutants and incumbents are treated equally over many simulation
						runs.
					</para>
				</listitem>
				<listitem>
					<para>
						The mutant strategy is assigned from a Gaussian distribution with a preconfigured standard
						deviation and the mean set to the incumbent strategy.
						The strategy is redrawn until it falls within the strategy domain <mathphrase>X</mathphrase>,
						inclusive of the lower bound, non-inclusive of the upper bound.
						The incumbent strategy is re-assigned when the number of mutants for that incumbent have reached
						the number of slots.
					</para>
				</listitem>
			</itemizedlist>
			<para>
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Installation</title>
		<para>
			You'll need a UNIX machine to use <command>bmigrate</command>.
			The more powerful your machine, the better:
			<command>bmigrate</command> takes advantage of as many processors as possible.
			It has been run on up to 64 cores.
			To date, the software has been compiled and run on <ulink url="https://www.apple.com/osx/">Mac OS X</ulink> Snow
			Leopard (10.6) and later, GNU/Linux (<ulink url="https://www.debian.org/">Debian</ulink>), and <ulink
				url="http://www.openbsd.org">OpenBSD</ulink>.
			In theory, the software may be ported to Microsoft Windows as well, but it's unlikely to happen without external
			contribution.
		</para>
		<sect2>
			<title>Binary Installation</title>
			<para>
				Application binaries are available for Mac OS X Snow Leopard (10.6) and later.
				To use these, simply download the ZIP file from the website.
				You may need to configure your system to allow downloaded binaries to run.
			</para>
		</sect2>
		<sect2>
			<title>Source Installation</title>
			<para>
				To compile <command>bmigrate</command>, you'll need a number of dependencies.
				First, you'll need a UNIX machine.
				(If you're running on Mac OS X, just use the binary application: it's a real pain in the neck to configure the
				build system for GTK+3 applications.)
			</para>
			<orderedlist>
				<title>Build dependencies</title>
				<listitem>
					<ulink url="https://www.gnu.org/software/make/">gmake</ulink>: GNU Make, for the build system (the
					default <command>make</command> implementation on Mac OS X and GNU/Linux)
				</listitem>
				<listitem>
					<ulink url="http://www.gtk.org/">GTK+3</ulink>: GNOME Toolkit, for the graphics
				</listitem>
				<listitem>
					<ulink url="https://www.gnu.org/software/gsl/">GSL</ulink>: GNU Scientific Library, for mathematical
					functions
				</listitem>
				<listitem>
					<ulink url="http://www.docbook.org/">DocBook5</ulink>: DocBook-XML, for this documentation
				</listitem>
				<listitem>
					<ulink url="http://libbsd.freedesktop.org/wiki/">libbsd</ulink>: BSD libraries (only relevant for
					GNU/Linux systems)
				</listitem>
			</orderedlist>
			<para>
				These are all available as packages for modern UNIX systems.
				If you're downloading and installing any components on you're own, something is wrong.
			</para>
			<para>
				To compile and install the software, simply run the following.
				(This will use <command>pkg-config</command> to locate relevant GNU tools.)
			</para>
			<screen>
% make
% sudo make install
			</screen>
			<para>
				If you're on a BSD system, you may need to use <command>gmake</command>, if <command>make</command> defaults to
				the BSD implemenation of the same utility.
			</para>
			<para>
				By default, this will install into <filename>/usr/local</filename>.
				To specify an alternative root, pass the <envar>PREFIX</envar> environment variable to the install command.
				Assuming that the <envar>PREFIX</envar><filename>/bin</filename> is in your <envar>PATH</envar>, you can then
				run the system by invoking <command>bmigrate</command>.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Mechanics</title>
		<para>
			Being a high-performance scientific application, <command>bmigrate</command> concerns itself a great deal with mechanics
			such as randomness, parallelism, and data-flow.
			This section briefly touches upon these concepts.
		</para>
		<sect2>
			<title>Data-Flow</title>
			<para>
				Having data analysed or graphed directly from simulation data would significantly slow down data collection.
				To accomodate for this, data is copied in several stages, minimising simulation lock contention and user
				interfacing stalling.
			</para>
			<variablelist>
				<varlistentry>
					<term>Hot Storage</term>
					<listitem>
						Statistics (e.g., on-line mutant fractions mean per incumbent) written to directly by simulation
						threads.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Hot Storage (LAB)</term>
					<listitem>
						When a simulation thread detects the copyout flag set by the main graphical thread, it copies
						hot storage into a hot storage look-aside buffer (LAB).
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Warm Storage</term>
					<listitem>
						When the main graphical thread requests data copyout by setting a flag with the simulation, a
						simulation thread that populated its LAB copies from the LAB into warm storage and unsets the
						copyout flag.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Cold Storage</term>
					<listitem>
						When the main graphical thread sees its data copyout flag has been unset, it copies from warm
						storage into cold storage.
						Cold storage is used for all graphing and analysis, as it does not change outside of the main
						graphical thread.
					</listitem>
				</varlistentry>
			</variablelist>
		</sect2>
		<sect2>
			<title>Parallelism</title>
			<para>
				Simulations may be executed in parallel if assigned multiple threads during <link linkend="configuration"
					endterm="configuration.title" />.
				By default, each simulation is assigned a single thread.
				Thus, there are several moments when synchronisation between threads occurs to ensure simulations and data-flow
				processes are race-free with minimum contention.
			</para>
			<itemizedlist>
				<listitem>
					Before each simulation, assignment of incumbent and mutant strategies must be synchronised.
					The index for both of these strategies increases monotonically within a critical section (modulo the
					lattice dimensions).
					For Gaussian-distributed mutants, of course, the mutant monotonicity is irrelevant.
				</listitem>
				<listitem>
					After each simulation, the result for a given incumbent must be tallied in a critical section.
					This is required because, in some situations, a single run might take long enough that another processor
					starts running with the same incumbent, with both finishing simultaneously.
				</listitem>
				<listitem>
					When data is copied from hot storage into the LAB, it is copied within a critical section.
					This prevents partial modification to the data in-copy.
				</listitem>
				<listitem>
					When the main graphical thread requests a data copyout, it does so in a critical section.
					This ensures that only a single simulation thread will perform the copyout, and also that the main
					calling thread won't have its copyout flag unset before all data has been copied.
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Randomness</title>
			<para>
				By default, <command>bmigrate</command> uses the MT19937 generator of Makoto Matsumoto and Takuji Nishimura.
				This ensures good-quality randomness with a very high period.
			</para>
			<para>
				Each simulation thread is allocated its own randomn number generator.
				Each generator is assigned seed from the ARC4 random number source.
			</para>
		</sect2>
	</sect1>
	<sect1 id="configuration">
		<title id="configuration.title">Configuration</title>
		<para>
			When invoked, <command>bmigrate</command> will pop up a configuration screen.
			You use this to configure and deploy simulations.
			To quit the system, simply press <guibutton>Quit</guibutton>.
			To start a simulation (after entering configuration data), press <guibutton>Simulate</guibutton>.
			The configuration screen will remain open so that you can start subsequent simulations.
		</para>
		<screenshot>
			<graphic fileref="screen-config.png" />
		</screenshot>
		<para>
			Begin by assigning <mathphrase>N</mathphrase>, <mathphrase>n</mathphrase>, and <mathphrase>m</mathphrase>.
		</para>
		<variablelist>
			<title>Environment Structure</title>
			<varlistentry>
				<term>Uniform</term>
				<listitem>
					<para>
						The simplest configuration of a fixed number of islands <mathphrase>N</mathphrase>; a fixed,
						uniform number of individuals per island <mathphrase>n</mathphrase>; and a probability
						<mathphrase>m</mathphrase> of inter-island migration uniform to all islands.
						The default is 100 individuals across 50 islands.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mapped</term>
				<listitem>
					<para>
						This is not yet used.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Next, configure the utility function <mathphrase>&pi;</mathphrase>, which dictates the reproduction of individuals.
		</para>
		<variablelist>
			<title>Game Configuration</title>
			<varlistentry>
				<term>Continuum</term>
				<listitem>
					<para>
						Configure a utility function accepting individuals' strategies.
						You can either select a preset function or provide one yourself.
					</para>
					<para>
						The utility function <mathphrase>&pi;</mathphrase> accepts the current individual's strategy
						<mathphrase>x</mathphrase>, the sum of all other individuals' strategies
						<mathphrase>X</mathphrase> on the individual's island, and the number of individuals
						<mathphrase>n</mathphrase> on the individual's island.  The function accepts basic binary and
						unary arithmetic operations, nested expressions, the <mathphrase>exp</mathphrase> function, the
						<mathphrase>sqrt</mathphrase> function, and double-precision numbers.
					</para>
					<para>
						You can also change the strategy domain for any individual's strategy, which is inclusive of the
						lower bound, non-inclusive of the upper bound.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Finite 2-strategy, 2-player</term>
				<listitem>
					<para>
						This is not yet used.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Lastly, configure the process machinery itself.
		</para>
		<variablelist>
			<title>Process Configuration</title>
			<varlistentry>
				<term>Threads</term>
				<listitem>
					<para>
						The number of threads of execution.
						The maximum number of threads is the number of processors (or cores) of your system.
						You should plan your simulations so as not to oversubscribe your machine, e.g., if you're
						running 4 simulations on a 64-processor machine, you should allocate 16 threads per simulation.
						(This assumes that each simulation is equally time-consuming.)
						Assume that each thread will consume 100% of a processor's resources.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Analysis</term>
				<listitem>
					<para>
						For now, this only accepts the multiple runs option.
						Here you can set the maximum number of generations per simulation run.
						Note that a simulation run may terminate before the maximum if a population type goes extinct.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Parameters</term>
				<listitem>
					<para>
						The linear transform from utility function to Poisson process mean.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Incumbents</term>
				<listitem>
					<para>
						This sets how finely the strategy domain is sliced for assigning incumbents and mutants to
						discrete strategies.
						For example, if this value is 100 (the default), then a strategy domain in the unit interval
						results in strategies of 0, 0.01, 0.02, ..., 0.99.
						A higher number will make a finer mesh, but take more time to process.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mutants</term>
				<listitem>
					<para>
						Determines how mutants are assigned.
						If discrete, mutants are assigned in sequence from the incumbent grid.
						If Gaussian, mutants are assigned from a Gaussian distribution around the incumbent strategy
						with the given standard deviation.
						The distribution is truncated to the strategy domain inclusive of the lower bound, non-inclusive
						of the upper bound.
						The Box-Muller algorithm is used for producing Gaussian-distributed random numbers.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Fit polynomial</term>
				<listitem>
					<para>
						If you wish to fit incumbents' mean mutant fraction to a polynomial during run-time, you may
						specify the degree of that polynomial here.
						If set to 0, fitting will not be performed.
						If set to non-zero, you may also specify that the fitting be weighed by the variance of each
						incumbent mean mutant fraction.
						The fitting algorithm is the modified Golub-Reinsch SVD algorithm with column scaling.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Name</term>
				<listitem>
					<para>
						A free-form name for the simulation.
						Defaults to the current time.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</sect1>
	<sect1>
		<title>Visualisation</title>
		<para>
			When you've configured a simulation, press <guibutton>Simulate</guibutton> to start the visualisation.
			A window will pop up visualising the simulation in a variety of ways.
			Each window visualises at least one simulation: to compare different simulations, you can drag and drop simulation
			windows into each other.
			On Mac OS X machines, window controls appear in the menu bar.
			On other UNIX machines, you can pop up a menu bar by right-clicking within a simulation window.
		</para>
		<sect2 id="samplemean">
			<title id="samplemean.title">Sample Mean</title>
			<para>
				The sample mean graphs incumbents on the x-axis and the mean mutant fraction after <mathphrase>T</mathphrase>
				generations (or when one of the types goes extinct&mdash;whichever comes first) over all runs to date on the y-axis.
				If an incumbent does not have any runs yet, it will display as zero.
				The graph y-maximum will automatically adjust to the highest simulation peak.
			</para>
			<screenshot>
				<graphic fileref="screen-win1.png" />
			</screenshot>
			<para>
				Each simulation is shown in the legend below the graph.
				The legend shows the simulation colour and name, as well as the number of runs involved in constructing the
				mean.
			</para>
		</sect2>
		<sect2 id="samplemeansigma">
			<title id="samplemeansigma.title">Sample Mean and Sigma</title>
			<para>
				This graph augments the <link linkend="samplemean" endterm="samplemean.title" /> graph with the standard
				deviation above and below each incumbent's mean.
			</para>
			<screenshot>
				<graphic fileref="screen-win2.png" />
			</screenshot>
			<para>
				The standard deviation is computed from the variance accumulated online using the Knuth/Welford algorithm.
			</para>
		</sect2>
		<sect2 id="samplemeanfitted">
			<title id="samplemeanfitted.title">Sample Mean and Fitted Polynomial</title>
			<para>
				If a non-zero degree for polynomial fitting was selected at <link linkend="configuration"
					endterm="configuration.title" />, this will show the <link linkend="samplemean"
					endterm="samplemean.title" /> along with that polynomial.
				Otherwise it will only show the <link linkend="samplemean" endterm="samplemean.title" />.
			</para>
			<screenshot>
				<graphic fileref="screen-win3.png" />
			</screenshot>
			<para>
				Unlike the <link linkend="samplemean" endterm="samplemean.title" /> or <link linkend="samplemeansigma"
					endterm="samplemeansigma.title" />, the data for this graph is computed roughly four times per second
				instead of with every run.
				This prevents excessive slow-down.
			</para>
		</sect2>
		<sect2>
			<title>Sample Mean, Fitted, Sigma</title>
			<para>
				Combine <link linkend="samplemeansigma" endterm="samplemeansigma.title" /> with <link linkend="samplemeanfitted"
					endterm="samplemeanfitted.title" />.
				If a fit polynomial was not provided during <link linkend="configuration" endterm="configuration.title" />, this
				is equivalent to just the <link linkend="samplemeansigma" endterm="samplemeansigma.title" />.
			</para>
			<screenshot>
				<graphic fileref="screen-win4.png" />
			</screenshot>
		</sect2>
	</sect1>
</article>
