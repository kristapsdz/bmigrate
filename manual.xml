<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<meta charset='utf-8' /> 
		<title>bmigrate manual</title>
		<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" />
		<link rel="stylesheet" href="manual.css" type="text/css" />
		<script type="text/x-mathjax-config">
			  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
		</script>
		<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	</head>
	<body>
		<header>
			<h1><a href="index.html">Simulating the Island Model of Evolutionary Algorithms</a></h1>
			<nav>
				<ul>
					<li>
						<a title="Download Source" href="snapshots/bmigrate.tgz">
							<span>Source Code</span>
							<i class="fa fa-gears"></i>
						</a>
					</li>
					<li>
						<a title="Archive" href="snapshots">
							<span>Source Archive</span>
							<i class="fa fa-archive"></i>
						</a>
					</li>
					<li>
						<a title="GitHub" href="https://github.com/kristapsdz/bmigrate">
							<span>GitHub</span>
							<i class="fa fa-github"></i>
						</a>
					</li>
					<li>
						<a title="Download Mac OS X Binary" href="http://cgi.kcons.eu/bmigrate/bmigrate.app.zip">
							<span>Mac Bundle</span>
							<i class="fa fa-apple"></i>
						</a>
					</li>
					<li>
						<a title="BibTeX Citation" href="bmigrate.bib">
							<span>Citation</span>
							<i class="fa fa-bookmark"></i>
						</a>
					</li>
				</ul>
			</nav>
		</header>
		<article>
			<p>
				<span class="nm">bmigrate</span> is a graphical high-performance scientific application simulating the
				island model for evolutionary algorithms.
				This manual documents the theory, operation, and implementation of <span class="nm">bmigrate</span> version @VERSION@.
				It is a work in progress: if you notice inconsistencies or wish clarification, please contact us through the
				links given on the <a href="index.html">main page</a>.
			</p>
			<ol>
				<li>
					<a href="#theory">Theory</a>
					<ol>
						<li><a href="#theory.generations">Generations</a></li>
						<li><a href="#theory.runs">Runs</a></li>
						<li><a href="#theory.simulation">Simulation</a></li>
					</ol>
				</li>
				<li>
					<a href="#implementation">Implementation</a>
					<ol>
						<li><a href="#implementation.dataflow">Data-flow</a></li>
						<li><a href="#implementation.parallelism">Parallelism</a></li>
						<li><a href="#implementation.randomness">Randomness</a></li>
						<li><a href="#implementation.precision">Precision</a></li>
					</ol>
				</li>
				<li>
					<a href="#installation">Installation</a>
					<ol>
						<li><a href="#installation.binary">Binary Installation</a></li>
						<li><a href="#installation.source">Source Installation</a></li>
					</ol>
				</li>
				<li>
					<a href="#configuration">Configuration</a>
					<ol>
						<li><a href="#configuration.environment">Environment Structures</a></li>
						<li><a href="#configuration.game">Game-play Configuration</a></li>
						<li><a href="#configuration.process">Process Configuration</a></li>
						<li><a href="#configuration.mapping">Map Configuration</a></li>
						<li><a href="#configuration.rangefind">Range-finding</a></li>
					</ol>
				</li>
				<li>
					<a href="#visualisation">Visualisation</a>
					<ol>
						<li><a href="#visualisation.control">Control</a></li>
						<li><a href="#visualisation.views">Views</a></li>
					</ol>
				</li>
				<li>
					<a href="#notation">Notation</a>
				</li>
				<li>
					<a href="#bibliography">Bibliography</a>
				</li>
			</ol>
			<section>
				<h2 id="theory">Theory</h2>
				<p>
					In this chapter, I'll describe the general functionality of <span class="nm">bmigrate</span>.
					When operating a <span class="nm">bmigrate</span> instance, you'll execute one or more simulations,
					which test the behaviour of a game configuration.
					More specifically, a <span class="firstterm">simulation</span> consists of one or more simulation <span
						class="firstterm">runs</span>, 
					each consisting of a finite sequence of <span class="firstterm">generations</span> implementing [<a
						href="#moran62">moran62</a>].
					In the simplest case, a <span class="nm">bmigrate</span> simulation executes the following:
				</p>
				<ol>
					<li>
						Initialise a simulation with a fixed number of islands $N$, individuals per island $n$, migration probability
						$m$, utility function $\pi$, and strategy domain $X$.
						These parameters are collectively called the simulation configuration, and are consistent within
						each simulation.
					</li>
					<li>
						Iterate over simulation runs:
						<ol>
							<li>
								Initialise all individuals as incumbents, each individual on an island, then
								assign one individual as a mutant.
								Assign a strategy to each individual based on the individual's type, incumbent
								or mutant.
								A strategy is a real-valued parameter $x$ passed to the utility function $\pi$.
								The effect is a population of individuals with a uniform incumbent strategy $x$
								spread over $N$ islands and a single individual with a mutant strategy $y$.
							</li>
							<li>
								Iterate over generations:
								<ol>
									<li>
										On each island, compute each individual's number of offspring
										(<span class="firstterm">reproduction</span>), which inherit the
										parent's type.
										The count of offspring is determined by the individual's
										strategy $x_i$, all other individuals' strategies $x_{-i}$, and
										the utility function $\pi$.
									</li>
									<li>
										Assign individuals' offspring to islands (<span
											class="firstterm">migration</span>).
										Probability of migration is determined by the simulation
										parameter $m$, though emigration is implemented in several ways,
										the simplest being selection of a random island.
									</li>
									<li>
										On each island with immigrants, replace a single inhabitant with a migrant
										(<span class="firstterm">selection</span> and <span
											class="firstterm">replacement</span>), then repeat.
									</li>
								</ol>
							</li>
							<li>
								Terminate the run after a fixed number of generations or when the global mutant or incumbent
								tally reaches zero.
							</li>
							<li>
								Re-assign the incumbent strategy, mutant strategy, initial mutant's island, and repeat.
							</li>
						</ol>
					</li>
				</ol>
				<p>
					See <a href="#notation">Notation</a> for a review of the mathematical notation and variable names.
				</p>
				<p>
					In the remaining sections of this chapter, I closely consider each step of the above sequence.
				</p>
				<section>
					<h3 id="theory.generations">Generations</h3>
					<p>
						When a generation begins, each island consists of a non-zero number of individuals of either a mutant or
						incumbent type, each with an assigned type-specific strategy.
						A generation proceeds exactly as follows:
					</p>
					<ol>
						<li>
							Compute an individual's reproductive fertility from a Poisson-distributed random number with mean
							$\alpha(1 + \delta\pi(x_i, x_{-i})$, where $\pi$ is a function accepting the individual's strategy $x_i$
							and all other individuals' strategies $x_{-i}$ on her island.
							For example, on an island with two individuals having strategies $x = 5$ and $y = 2$, with the function
							simply being $x_i + x_{-i}$, the first individual's fertility is $\alpha(1 + 15\delta)$ and the second
							individual's is $\alpha(1 + 12\delta)$.
							Since fertility is Poissonian, it is never negative.
						</li>
						<li>
							Once each individual's offspring count has been computed, the offspring (which inherit the parent's type)
							migrate to other islands.
							With probability $m$, an offspring will migrate to a randomly-selected other island.
							Otherwise, the offspring will migrate to the parent's (i.e., the current) island.
						</li>
						<li>
							Lastly, on each island with a queue of individuals migrated from other islands (or the same island), a single
							randomly-selected individual replaces a single randomly-selected individual on the island.
							If an island has no waiting individuals, nothing happens to that island.
						</li>
					</ol>
					<p>
						The tally of mutants and incumbents globally and per-island is recomputed following each generation.
					</p>
				</section>
				<section>
					<h3 id="theory.runs">Runs</h3>
					<p>
						A simulation run begins with all individuals but one being incumbents.
						The mutant type is assigned to a single individual in the total population.
						Each individual is assigned a strategy $x_i$ based on their type.
						A simulation run proceeds exactly as follows:
					</p>
					<ol>
						<li>
							Execute a single generation.
						</li>
						<li>
							Increment the generation count.
						</li>
						<li>
							If the generation meets a fixed termination count, stop the run.
							If the global tally of mutants or incumbents reaches zero, stop the run.
							Otherwise, repeat.
						</li>
					</ol>
					<p>
						When a simulation run terminates, the fraction of mutants remaining is recorded.
						After accumulating statistics, the run is re-started in its initial configuration with mutant strategy,
						incumbent strategy, and initial mutant island re-assigned.
					</p>
				</section>
				<section>
					<h3 id="theory.simulation">Simulation</h3>
					<p>
						Simulations are configured with a number of islands $N$, individuals per island $n$ (which may be non-uniform),
						migration probability $m$ (which may be non-uniform and asymmetric), utility function $\pi$, and strategy domain
						$X$, maximum generation $T$, and variables $\alpha$ and $\delta$ for transforming utility into the Poisson mean.
						A simulation repeats runs until stopped or paused by the system user.
					</p>
					<p>
						For each run, the incumbent strategy is assigned from a discrete grid over the real-valued strategy domain $X$.
						The grid's boundaries are inclusive of the domain's lower bound, non-inclusive of the domain's upper bound.
						Thus, if $X \in [0, 1)$ and the grid has 100 slots, possible strategies will be $0, 0.01, 0.02, \cdots, 0.99$.
						The mutant strategy may be configured in two ways:
					</p>
					<ul>
						<li>
							After each simulation run, the mutant strategy is assigned from the next grid position, e.g.,
							from 0.01 to 0.02.
							If the grid position is at the upper bound, it is re-set to the lower bound.
							The incumbent strategy is only re-assigned when the mutant grid position is re-set to the lower
							bound.
							This behaviour ensures that all mutants and incumbents are treated equally over many simulation
							runs.
						</li>
						<li>
							The mutant strategy is assigned from a Gaussian distribution with a preconfigured standard
							deviation and the mean set to the incumbent strategy.
							The strategy is redrawn until it falls within a strategy domain that intersects $X$, inclusive of the
							lower bound, non-inclusive of the upper bound.
							The incumbent strategy is re-assigned when the number of mutants for that incumbent have reached
							the number of slots.
						</li>
					</ul>
					<p>
						When the incumbent strategy reaches its upper bound, it resets to the lower bound.
						At this point, the initial mutant island is also incremented.
						The initial mutant island will also wrap when it completes the last island.
					</p>
				</section>
			</section>
			<section>
				<h2 id="implementation">Implementation</h2>
				<p>
					Being a high-performance scientific application, <span class="nm">bmigrate</span> concerns itself a great deal with mechanics
					such as randomness, parallelism, and data-flow.
					This section briefly touches upon these concepts.
				</p>
				<section>
					<h3 id="implementation.dataflow">Data-Flow</h3>
					<p>
						Data-flow defines how data moves from simulations to graphed output.
						Having data analysed or graphed directly from simulation data would significantly slow down data collection.
						To minimise simulation and interface stalling, data is copied and translated in several stages.
						In general, data is <span class="firstterm">produced</span> by the simulation threads and
						<span class="firstterm">consumed</span>, periodically and in several stages, by the main graphical thread.
					</p>
					<dl>
						<dt>Hot Storage</dt>
						<dd>
							Statistics (e.g., on-line mutant fractions mean per incumbent) are written directly to
							hot storage by simulation threads.
							<span class="firstterm">Hot</span> refers to the high frequency of data access between the simulation
							threads.
						</dd>
						<dt>Hot Storage Look-aside Buffer</dt>
						<dd>
							When the main graphical thread wishes to read fresh data for graphical display, it sets
							a copy flag to copy-out.
							The first simulation thread to see that this flag has been set to copy-out updates the
							flag to copy-pending and copies the hot storage into a look-aside bufffer.
							Hot storage may then continue to be modified by the simulation threads.
						</dd>
						<dt>Warm Storage</dt>
						<dd>
							After copying data from hot storage into a look-aside buffer, the thread that updated
							the copy flag copies the look-aside buffer into warm storage.
							<span class="firstterm">Warm</span> refers to the low frequency of data access between the main
							graphical thread and the copying simulation thread.
							During the copy, the thread also performs more expensive statistical operations (such as
							minimum mutant fraction, or fitting of data) as it copies the data.
							The thread then clears the copy flag.
						</dd>
						<dt>Cold Storage</dt>
						<dd>
							When the main graphical thread detects that the copy flag has been cleared, it copies
							from warm storage into cold storage.
							<span class="firstterm">Cold</span> means that the data is not changed by anybody but the controlling
							(graphical main) thread.
							The main graphical thread also performs some statistical analysis during the copy.
						</dd>
					</dl>
					<p>
						This sequence ensures a minimum degree of contention between threads.  
						The main graphical thread needs only to wait for the copy flag to be unset before copying the data into its own
						thread of operation.
						The simulation threads need only wait for the look-aside copy, at which point only one thread is used for
						remaining data copy and statistical analysis.
					</p>
				</section>
				<section>
					<h3 id="implementation.parallelism">Parallelism</h3>
					<p>
						Simulations may be executed in parallel if assigned multiple threads during <a
							href="#configuration.title">configuration</a>.
						By default, each simulation is assigned a single thread.
						Thus, there are several moments when synchronisation between threads occurs to ensure simulations and data-flow
						processes are race-free with minimum contention.
					</p>
					<ul>
						<li>
							Before each simulation, assignment of incumbent and mutant strategies must be synchronised.
							The index for both of these strategies increases monotonically within a critical section (modulo the
							lattice dimensions).
							For Gaussian-distributed mutants, of course, the mutant monotonicity is irrelevant.
						</li>
						<li>
							After each simulation, the result for a given incumbent must be tallied in a critical section.
							This is required because, in some situations, a single run might take long enough that another processor
							starts running with the same incumbent, with both finishing simultaneously.
						</li>
						<li>
							When data is copied from hot storage into the look-aside buffer, it is copied within a critical section.
							This prevents partial modification to the data in-copy.
						</li>
						<li>
							When the main graphical thread requests a data copyout, it does so in a critical section.
							This ensures that only a single simulation thread will perform the copyout, and also that the main
							calling thread won't have its copyout flag unset before all data has been copied.
						</li>
					</ul>
				</section>
				<section>
					<h3 id="implementation.randomness">Randomness</h3>
					<p>
						By default, <span class="nm">bmigrate</span> uses the MT19937 (Mersenne-Twister) generator of [<a
							href="#matsumoto98">matsumoto98</a>].
						This ensures good-quality randomness with a very high period.
						(There is currently no facility in <span class="nm">bmigrate</span> for handlng period roll-over.)
					</p>
					<p>
						Each simulation thread is allocated its own randomn number generator.
						Each generator is assigned seed from <span class="function">arc4random</span>, which is implemented differently across
						operating systems.
						This ensures that all threads produce independent random variables.
					</p>
				</section>
				<section>
					<h3 id="implementation.precision">Precision</h3>
					<p>
						All floating-point operations of <span class="nm">bmigrate</span> use double-precision (type <span
							class="type">double</span>) floating point numbers.
						The statistical algorithms used (see links to algorithm descriptions) provide robust numerical stability.
					</p>
					<p>
						Integral operations (counters) use unsigned 64-bit integers (type <span class="type">uint64_t</span>).
						No checking is done for additive or multiplicative overflow as a simulation with more than $2^{64}$ runs is
						pretty unlikely.
					</p>
				</section>
			</section>
			<section>
				<h2 id="installation">Installation</h2>
				<p>
					In short, you'll need a UNIX machine (Mac OS X, Linux, BSD, etc.) to use <span class="nm">bmigrate</span>.
					At this time, Microsoft Windows builds are not available&#8212;please contact us if you have the
					knowledge (and wherewithal!) to accomplish this.
					If you're using Mac OS X, we strongly suggest that you use the pre-compiled <a
						href="#installation.binary">application bundle</a>.
					Otherwise, you'll need to download and compile from the source.
					In general, the more powerful your machine, the better: <span class="nm">bmigrate</span> takes advantage
					of as many processors as possible.
					It regularly runs on machines ranging from single core laptops to a sixty-four core workstation.
				</p>
				<section>
					<h3 id="installation.binary">Binary Installation</h3>
					<p>
						Application binaries are available for Mac OS X Lion (10.7) and later.
						To use these, simply download the <a
							href="http://cgi.kcons.eu/bmigrate/bmigrate.app.zip">application</a>, un-archive, and
						double-click to run!
						You may need to configure your system to allow downloaded binaries to run: find this option in
						the Security &amp; Privacy settings of your System Preferences.
					</p>
				</section>
				<section>
					<h3 id="installation.source">Source Installation</h3>
					<p>
						It has been compiled and run on <a href="https://www.apple.com/osx/">Mac OS X</a> Snow
						Leopard (10.6) and later, GNU/Linux (<a href="https://www.debian.org/">Debian</a>), and <a
							href="http://www.openbsd.org">OpenBSD</a>.
					</p>
					<p>
						To compile <span class="nm">bmigrate</span>, you'll need to install a number of dependencies.
						(If you're running on Mac OS X, just use the binary application: it's a real pain in the neck to configure the
						build system for GTK+3 applications.)
						Consult the documentation for your operating system on how to install these.
					</p>
					<ol>
						<li>
							<a href="https://www.gnu.org/software/make/">gmake</a>: GNU Make, for the build system (the
							default <code>make</code> implementation on Mac OS X and GNU/Linux)
						</li>
						<li>
							<a href="http://www.gtk.org/">GTK+3</a>: GNOME Toolkit, for the graphics
						</li>
						<li>
							<a href="http://kristaps.bsd.lv/kplot">kplot</a>: Plotting library
						</li>
						<li>
							<a href="https://www.gnu.org/software/gsl/">GSL</a>: GNU Scientific Library, for mathematical
							functions
						</li>
						<li>
							<a href="http://libbsd.freedesktop.org/wiki/">libbsd</a>: BSD libraries (only relevant for
							GNU/Linux systems)
						</li>
					</ol>
					<p>
						These are all available as packages for modern UNIX systems.
						(If you're downloading and installing any components on you're own, something is wrong!)
						To compile and install the software, simply run the following.
						(This will use <code>pkg-config</code> to locate relevant GNU tools.)
					</p>
					<pre>% make
% sudo make install</pre>
					<p>
						If you're on a BSD system, you may need to invoke <code>gmake</code> if <code>make</code> defaults
						to the BSD implemenation of the same utility.
					</p>
					<p>
						By default, this will install into <span class="file">/usr/local</span>.
						To specify an alternative root, pass the <span class="env">PREFIX</span> environment variable to the install command.
						Assuming that <span class="file">$PREFIX/bin</span> is in your <span class="env">PATH</span>, you can then run the system by
						invoking <span class="nm">bmigrate</span>.
					</p>
				</section>
			</section>
			<section>
				<h2 id="configuration">Configuration</h2>
				<p>
					When invoked, <span class="nm">bmigrate</span> will pop up a configuration screen.
					The configuration screen allows you to define the parameters for a simulation&mdash;the window will stay
					open for as long as any simulations are running, and allow you to start new simulations along existing
					ones.
					To quit <span class="nm">bmigrate</span>, simply press <q>Quit</q>.
					To start a simulation (after entering configuration data), press <q>Simulate</q>.
					If your parameters are faulty, you will be informed as such and a simulation will not begin until you've
					corrected all of the errors.
				</p>
				<p>
					If you want to see the effects of your parameters on reproduction (i.e., given your utility function, number of
					individuals per island, strategy space, and normalisation parameters), then click <q>Range-Find</q> (see
					<a href="#configuration.rangefind">Range-finding</a>).
					This will start a process that scans the strategy-space and produces the minimum, maximum, and mean values given as the
					Poisson random number mean.
				</p>
				<figure>
					<img src="screen-config.png" alt="Configuration Screen"/>
				</figure>
				<section>
					<h3 id="configuration.environment">Environment Structure</h3>
					<p>
						Begin by assigning $N$, $n$, and $m$.
						This constitutes the environment structure of the game; or in other words, the physical layout of the islands, $m$ and
						so on.
						There are three distinct methods of providing this information: <span
							class="firstterm">uniform</span>, for uniform parameterisation across individuals and
						islands;
						<span class="firstterm">variable</span>, for non-uniform island sizes; and
						<span class="firstterm">mapped</span>, for non-uniform island parameterisation and inter-island
						
						configuration.
					</p>
					<dl>
						<dt>
							Uniform
						</dt>
						<dd>
							The simplest (and fastest!) configuration of a fixed number of islands $N$ (at least
							two); a fixed, uniform number of individuals per island $n$ (at least two); and a
							probability $m$ of inter-island migration uniform to all [other] islands.  
							You'll probably want to use this configuration as a baseline in simulations.
						</dd>
						<dt>
							Variable
						</dt>
						<dd>
							Non-uniform individuals (at least two) per island.
							Individual's uniform probability of migration, $m$, must also be applied.
							If you specify an equal number of islanders for all islands (and zero value for the
							shot-clock mean), this will revert to the uniform configuration.
							You can also specify the Poisson mean of a per-island shot-clock of when an island will
							be checked for <q>wiping out</q>.
							When an island's shot-clock elapses, the island will have its utilities summed and
							transformed into a probability as follows:
							$$
							\text{coeff}\cdot\left(exp(-\sum_i \pi(\lambda_i)\right)
							$$
							Here, $\lambda_i$ is the Poisson mean of an islander $i$ given the payoff function $\pi$
							and parameters.
							The coefficient is given in the <q>island death coefficient</q> value.
							If the probability is satisfied by a randomly-drawn number in the unit interval, the
							island is wiped out.
							Otherwise, the shot-clock is reset.
							Wiped-out islands have all of their inhabitants removed and the shot-clock, reset.
							For example, if an island is selected for wiping out at $t_\lambda$, and the new
							Poisson-random shot-clock value is $p$, the next check will be $t_\lambda + 1 + p$.
							At time $t_\lambda$ and after, the island will accept random immigrants until the island meets
							the expected population, at which point it resumes the normal random-replace method.
							If an island is selected to be killed off when it has no inhabitants, the shot-clock is
							merely reset.
							Obviously, islands with no inhabitants will not generate any offspring.
						</dd>
						<dt>Mapped</dt>
						<dd>
							Put individuals on islands on the Earth's surface, allowing for varying methods of
							inter-island migration probability calculation.
							<p>
								The map type specifies how the map is supplied.
								It is either a <a href="http://www.opengeospatial.org/standards/kml/">KML</a>
								map file populated with two or more <code>Placemark</code> sections with
								appropriate <code>coordinates</code> (see <a
									href="#configuration.mapping">Mapping</a> for details);
								a random map with a uniform number of islanders per island;
								or a toroidal map, where islands are evenly placed along the equator.
							</p>
							<p>
								Inter-island migration (that is, once an individual chooses to migrate with
								probability $m$, which island she selects) is computed as either uniform random
								(i.e., disregarding the game structure);
								the normalised inverse-square distance between each island, where distance is
								defined over the Earth's surface; 
								nearest neighbour, where the nearest neighbour (over the Earth's surface) has
								full probability of migration; or
								two nearest neighbours, where the two nearest neighbours (over the Earth's
								surface) have even probability of migration.
							</p>
							<p>
								The index island defines which island accepts the mutant for each simulation
								run.  (See <a href="#theory.runs">Runs</a>.)
								In general, one will start the mutant on a random island.
								In some cases, however, one may fix the island.
								(This will be clamped to the total number of islands.)
							</p>
						</dd>
					</dl>
				</section>
				<section>
					<h3 id="configuration.game">Game-play Configuration</h3>
					<p>
						Next, configure the material payoff $\pi$, which dictates the reproduction of individuals.
						Note that payoffs are not provided directly to the Poisson generator, but are linearly transformed as
						described in <a href="#theory.generations">Generations</a>.
					</p>
					<p>
						The utility function $\pi$ accepts the current individual's strategy $x$, the sum of all other
						individuals' strategies $X$ on the individual's island, and the number of individuals $n$ on the
						individual's island.  
						The function accepts basic binary and unary arithmetic operations, nested expressions, the
						<code>exp</code> (exponential) function, the <code>sqrt</code> (square root) function, and
						double-precision numbers.
					</p>
					<p>
						You can also change the strategy domain for the incumbent's strategy, which is inclusive of the
						lower bound, non-inclusive of the upper bound.
						(The mutant's strategy domain is applied elsewhere.)
					</p>
				</section>
				<section>
					<h3 id="configuration.process">Process Configuration</h3>
					<p>
						Finally, configure the process machinery itself.
						This involves both the machinery itself and how it relates to hardware (parallelism) and also how payoffs are
						normalised.
					</p>
					<dl>
						<dt>Threads</dt>
						<dd>
							The number of threads of execution.
							The maximum number of threads is the number of processors (or cores) of your system.
							You should plan your simulations so as not to oversubscribe your machine, e.g., if you're
							running 4 simulations on a 64-processor machine, you should allocate 16 threads per simulation.
							(This assumes that each simulation is equally time-consuming.)
							Assume that each thread will consume 100% of processor or core resources.
							<p>
								The number of reserved threads is the sum of all threads for simulations, regardless of state;
								running threads show only the count of non-paused (i.e., active) simulations.
							</p>
						</dd>
						<dt>Generations</dt>
						<dd>
							The maximum number of generations per simulation run.
						</dd>
						<dt>Parameters</dt>
						<dd>
							The linear transform from utility function to Poisson process mean, $\alpha(1 +
							\delta\pi)$.
						</dd>
						<dt>Strategy slices</dt>
						<dd>
							This sets how finely the strategy domain is sliced for assigning incumbents and mutants
							(if discrete) to discrete strategies.
							For example, if this value is 100 (the default), then a strategy domain in the unit interval
							results in strategies of $0, 0.01, 0.02, \ldots, 0.99$.
							A higher number will make a finer mesh, but take more time to process.
						</dd>
						<dt>Mutants</dt>
						<dd>
							Determines how mutants are assigned.
							If discrete, mutants are assigned in slices within the strategy domain.
							If Gaussian, mutants are assigned from a Gaussian distribution around the incumbent strategy
							with the given standard deviation.
							The distribution is truncated to the given strategy domain, inclusive of its lower bound,
							non-inclusive of the upper bound.
							This strategy domain must be a superset of the incumbent domain $X$.
							The Box-Muller algorithm is used for producing Gaussian-distributed random numbers.
						</dd>
						<dt>Fit polynomial</dt>
						<dd>
							If you wish to fit incumbents' mean mutant fraction to a polynomial during run-time, you may
							specify the degree of that polynomial here.
							If set to 0, fitting will not be performed.
							If set to non-zero, you may also specify that the fitting be weighed by the variance of each
							incumbent mean mutant fraction.
							The fitting algorithm is the modified Golub-Reinsch SVD algorithm with column scaling.
						</dd>
						<dt>Name</dt>
						<dd>
							A free-form name for the simulation.
							Defaults to the current time.
							You can set the name to auto-fill by tying it to a number of inputs.
							When these inputs change, the auto-fill name will change as well.
							Setting it to <q>None</q> will disable this feature.
						</dd>
					</dl>
				</section>
				<section>
					<h3 id="configuration.mapping">Mapping</h3>
					<p>
						<span class="nm">bmigrate</span> has extensive support for extracting population structures from
						maps, specifically from and to <a href="http://www.opengeospatial.org/standards/kml/">KML</a>
						map files.
						A common way of creating and manipulating KML files is with <a
							href="https://www.google.com/earth/">Google Earth</a>.
					</p>
					<p>
						During <a href="#configuration">Configuration</a>, one can provide a map file from which population
						sizes and inter-island migration probabilities are computed.
						Each island corresponds to a KML <code>Placemark</code>.
						The coordinates of the island are extracted from its <code>coordinates</code> tuple.
						Lastly, if the string <code>@@population=NNN@@</code> appears in any text segment within the <code>Placemark</code>
						(e.g., within the <code>Description</code>), the <code>NNN</code> will be used as the island's population.
						If it isn't a valid number, it will raise an error.
						The default island population is 2.
					</p>
					<p>
						One can also save map files (as a directory of KML files, accomodating for multiple simulations).
						If a map was provided during configuration, the same map file is outputted, but certain key words will be replaced by
						the simulation statistics:
					</p>
					<dl>
						<dt><code>@@mean@@</code></dt>
						<dd>
							The mean mutant fraction over all simulation runs when the mutant is initialised
							on the given island.
						</dd>
						<dt><code>@@meanpct@@</code></dt>
						<dd>
							Like <code>@@mean@@</code>, but normalised as a percentage of all islands' accumulated fraction.
						</dd>
						<dt><code>@@population@@</code> or <code>@@population=NNN@@</code></dt>
						<dd>
							The island population.
						</dd>
						<dt><code>@@stddev@@</code></dt>
						<dd>
							The standard deviation of the mean mutant fraction over all simulation runs when the mutant is
							initialised on the given island.
						</dd>
					</dl>
				</section>
				<section>
					<h3 id="configuration.rangefind">Range-finding</h3>
					<p>
						If you click the <q>Range-find</q> button, the current parameters will be used to find the
						minimum, maximum, and average fecundity (Poisson mean).
					</p>
					<p>
						The range-finder will iterate over all possible strategies for the incumbent and mutant, with
						the given number of <q>slices</q> over the strategy space.
						Unlike in the real simulation, where mutant strategies may be randomly distributed, the
						range-finder will iterate over all possible strategies over a lattice.
						Thus, the average is an average over the lattice, and may not reflect the average of your
						simulation!
						For each configuration, all possible mutant values (up to the number of islanders) is tried.
					</p>
					<p>
						You can stop the range-finder at any time.
					</p>
				</section>
			</section>
			<section>
				<h2 id="visualisation">Visualisation</h2>
				<p>
					When you've configured a simulation, press <q>Simulate</q> to start the visualisation.
					If all values validate, a window will pop up visualising the simulation in a variety of ways.
					If values don't validate, they'll be noted and you can fix them.
					Each field must be properly filled in before the simulation begins.
					Don't worry&mdash;you'll be able to review your simulation's configuration while it's running!
				</p>
				<p>
					Simulations are reference-counted: when you start a simulation, it has a single referring window.
					Each window visualises at least one simulation: to compare different simulations, you can drag and drop simulation
					windows into each other.
					This will increase the reference to individual simulations.
					The same happens if you clone a view.
					When you close a window, each simulation is dereferenced.
					When no windows reference a simulation, it will terminate.
				</p>
				<section>
					<h3 id="visualisation.control">Control</h3>
					<p>
						Simulation and analyses are controlled from the menu bar.
						Simulations are controlled with the <q>Tools</q> and <q>File</q> menu.
						Analysis is controlled with the <q>View</q> menu.
						If you're running on Mac OS X, the menu bar is the top-most menubar.
						On other UNIX systems, menu bars are part of each simulation window.
					</p>
					<section>
						<h4>File</h4>
						<p>
							You can perform the usual <q>Quit</q> and <q>Close</q> operations (the latter will
							dereference each simulation, just like closing the window by way of your window
							manager).
							You can also <q>Clone</q> your view, which will duplicate the window (including all
							simulations).
							You can also save a windows's current view of its simulations as a data file (described in each <a
								href="#visualisation.views">Views</a>).
							You can choose either PDF, PS, EPS, or PNG as possible output types.
							You can export all views of all simulations into a folder as well, which will include a
							<span class="file">README.txt</span> of the configuration.
						</p>
					</section>
					<section>
						<h4>View</h4>
						<p>
							Switch the current view, which consists of one or more simulations, to another.
							These are listed in <a href="#visualisation.views">Views</a>.
						</p>
					</section>
					<section>
						<h4>Tools</h4>
						<p>
							From here you can pause or unpause simulations.
							These apply to all simulations in the current window.
							You can also register a directory into which all views will be auto-exported once per minute.
							(This is handy when running extensive simulations over an iffy network.)
						</p>
					</section>
				</section>
				<section>
					<h3 id="visualisation.views">Views</h3>
					<p>
						Each window may have an arbitrary number of simulations and is connected to a particular view of those
						simulations.
						This is shown in the <q>View</q> notebook panel of the simulation window.
						The <q>Configuration</q> panel lists the simulation's configuration.
						You can choose a new view from the <q>View</q> menu.
						The current view is reflected in the window's title bar.
					</p>
					<section>
						<h4 id="visualisation.samplemean">Mutant Mean</h4>
						<p>
							The sample mean graphs incumbent strategies on the $x$-axis and the mean mutant fraction
							after $T$ generations (or when one of the types goes extinct&mdash;whichever comes
							first) over all runs to date on the $y$-axis.
							If an incumbent does not have any runs yet, it will display as zero.
							The graph $y$-maximum will automatically adjust to the highest simulation peak.
						</p>
					</section>
					<section>
						<h4 id="visualisation.samplemeansigma">Mutant Mean and Standard Deviation</h4>
						<p>
							This graph augments the <a href="#visualisation.samplemean">Mutant Mean</a> graph with
							the standard deviation above and below each incumbent's mean.
							The standard deviation below is truncated to zero when negative.
							The mutant mean graph is shown in a solid colour; the standard deviation above and
							below, in a transparent rendering of the same.
						</p>
						<p>
							The standard deviation is computed from the unbiased sample variance algorithm of [<a
								href="#knuth98">knuth98</a>] and [<a href="#welford62">welford62</a>].
							It shouldn't be confused with the population standard deviation, which is computed over
							all $t$ samples (simulation runs).
							This is an unbiased estimate computed over $t-1$ samples.
						</p>
					</section>
					<section>
						<h4 id="visualisation.samplemeanfitted">Fitted Polynomial</h4>
						<p>
							If a non-zero degree for polynomial fitting was selected at <a
								href="#configuration">Configuration</a>, this will show the <a
								href="#visualisation.samplemean">Mutant Mean</a> (transparent line) along with the fitted
							polynomial (solid line).
							If a zero degree was selected, it will only show the <a
								href="#visualisation.samplemean">Mutant Mean</a>.  
							If the weighted option was selected during <a href="#configuration">Configuration</a>,
							the standard deviation (see <a href="#visualisation.samplemeansigma">Mutant Mean and
								Standard Deviation</a>) will be used as a weight.
						</p>
						<p>
							Unlike the <a href="#visualisation.samplemean">Mutant Mean</a> or <a
								href="#visualisation.samplemeansigma">Mutant Mean and Standard Deviation</a>,
							the polynomial for this graph is computed roughly four times per second instead of with every
							run.
							This prevents excessive slow-down.
							The implementations are <span class="function">gsl_multifit_wlinear</span> and
							<span class="function">gsl_multifit_linear</span> for the weighted and non-weighted fitting algorithm,
							respectively, of the <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a>.
							Both are described in the <q>Statistics</q> chapter of [<a
								href="#barnett96">barnett96</a>].
						</p>
					</section>
					<section>
						<h4 id="visualisation.mutantextinctions">Mutant Extinctions</h4>
						<p>
							The percentage of simulation runs to date of each incumbent where the mutant population
							goes extinct before the maximum simulation time $T$.
							The $x$-axis shows incumbent strategy.
							The $y$-axis shows the fraction of mutant extinctions in the unit interval.
							If the incumbent does not yet have any data (i.e., no runs yet), it shows zero.
							See <a href="#visualisation.incumbentextinctions">Incumbent Extinctions</a>.
						</p>
					</section>
					<section>
						<h4 id="visualisation.incumbentextinctions">Incumbent Extinctions</h4>
						<p>
							The percentage of simulation runs to date of each incumbent where the incumbent population goes extinct
							before the maximum simulation time $T$.
							The $x$-axis shows incumbent strategy.
							The $y$-axis shows the fraction of incumbent extinctions in the unit interval.
							If the incumbent does not yet have any data (i.e., no runs yet), it shows zero.
							See <a href="#visualisation.mutantextinctions">Mutant Extinctions</a>.
						</p>
					</section>
					<section>
						<h4 id="visualisation.smoothedsamplemean">Smoothed Mutant Mean</h4>
						<p>
							This is the same as <a href="#visualisation.samplemean">Mutant Mean</a> except with the
							data points (sample mean per incumbent strategy on the $x$-axis) smoothed by a moving
							average.
							The degree of this moving average is set during <a
								href="#configuration">Configuration</a>, defaulting to three.
						</p>
						<p>
							The moving average is computed for each interior point by replacing the current point
							with the average of the prior and subsequent points.
							The border points (i.e., the points that cannot exercise a full smooth sample) are not
							adjusted.
							The moving average is not cascading: when replacing points, the prior and subsequent
							point used for averaging are from the original data set, not the smoothed data set.
						</p>
					</section>
					<section>
						<h4>Smoothed Mutant Extinctions</h4>
						<p>
							This is the same as <a href="#visualisation.mutantextinctions">Mutant Extinctions</a> except with
							the data points (extinction fraction per incumbent strategy on the $x$-axis) smoothed by
							a moving average.
							See <a href="#visualisation.smoothedsamplemean">Smoothed Mutant Mean</a> for the moving average
							calculation.
						</p>
					</section>
					<section>
						<h4>Smoothed Incumbent Extinctions</h4>
						<p>
							This is the same as <a href="#visualisation.incumbentextinctions">Incumbent Extinctions</a> except with
							the data points (extinction fraction per incumbent strategy on the $x$-axis) smoothed by
							a moving average.
							See <a href="#visualisation.smoothedsamplemean">Smoothed Mutant Mean</a> for the moving average
							calculation.
						</p>
					</section>
					<section>
						<h4 id="visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</h4>
						<p>
							Accumulate the minimum value of <a href="#visualisation.samplemeanfitted">Fitted
								Polynomial</a> into a probability mass function, displayed either as a PDF or as
							an empirical CDF.
						</p>
						<p>
							The minimum value is the first minimum: if multiple subsequent minima are detected (a
							basin), they are ignored.
							This might skew values toward smaller minima.
							Minima are accumulated whenever the polynomial is re-computed.  (Four times per second.)
						</p>
					</section>
					<section>
						<h4 id="visualisation.samplemeanminpdf">Mutant Mean Minimum (PDF, CDF)</h4>
						<p>
							Accumulate the minimum value of <a href="#visualisation.samplemean">Mutant Mean</a> into
							a probability mass function, displayed either as a PDF or as an empirical CDF.
							See <a href="#visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</a>
							for details on computing the distribution.
						</p>
					</section>
					<section>
						<h4 id="visualisation.mutantextinctionminpdf">Mutant Extinctions Minimum (PDF, CDF)</h4>
						<p>
							Accumulate the minimum value of <a href="#visualisation.mutantextinctions">Mutant
								Extinctions</a> into a probability mass function, displayed either as a PDF or
							as an empirical CDF.
							See <a href="#visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</a>
							for details on computing the distribution.
						</p>
					</section>
					<section>
						<h4 id="visualisation.incumbentextinctionminpdf">Incumbent Extinctions Minimum (PDF, CDF)</h4>
						<p>
							Accumulate the minimum value of <a href="#visualisation.incumbentextinctions">Incumbent
								Extinctions</a> into a probability mass function, displayed either as a PDF or
							as an empirical CDF.
							See <a href="#visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</a>
							for details on computing the distribution.
						</p>
					</section>
					<section>
						<h4 id="visualisation.exittimepdf">Exit Times (PDF, CDF)</h4>
						<p>
							Accumulate the exit time of simulation runs (i.e., the time $t$ at which point the
							simulation exited due to extinction or reaching $T$) into a probability mass function or
							an empirical CDF.
							See <a href="#visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</a>
							for details on computing the distribution.
						</p>
					</section>
					<section>
						<h4>Fitted Polynomial Minimum History</h4>
						<p>
							Accumulate the last 256 instantaneous minimum values (approximately the last minute) of
							<a href="#visualisation.samplemeanfitted">Fitted Polynomial</a>.
						</p>
					</section>
					<section>
						<h4>Mutant Mean Minimum History</h4>
						<p>
							Accumulate the last 256 instantaneous minimum values (approximately the last minute) of <a
								href="#visualisation.samplemeanminpdf">Mutant Mean Minimum</a>.
						</p>
					</section>
					<section>
						<h4>Fitted Polynomial Minimum Mean</h4>
						<p>
							Plot the incumbent strategy distribution mean of <a
								href="#visualisation.fittedpolyminpdf">Fitted Polynomial Minimum (PDF, CDF)</a>
							within the standard deviation error bars (above and below), which are truncated below at
							zero.
							Each simulation is plotted as a separate point.
						</p>
					</section>
					<section>
						<h4>Mutant Mean Minimum Mean</h4>
						<p>
							Plot the incumbent strategy distribution mean of <a
								href="#visualisation.samplemeanminpdf">Mutant Mean Minimum (PDF, CDF)</a> within
							the standard deviation error bars (above and below), which are truncated below at zero.
							Each simulation is plotted as a separate point.
						</p>
					</section>
					<section>
						<h4>Mutant Extinctions Minimum Mean</h4>
						<p>
							Plot the incumbent strategy distribution mean of <a
								href="#visualisation.mutantextinctionminpdf">Mutant Extinctions Minimum (PDF,
								CDF)</a>
							within the standard deviation error bars (above and below), which are truncated below at
							zero.
							Each simulation is plotted as a separate point.
						</p>
					</section>
					<section>
						<h4>Incumbent Extinctions Minimum Mean</h4>
						<p>
							Plot the incumbent strategy distribution mean of <a
								href="#visualisation.incumbentextinctionminpdf">Incumbent Extinctions Minimum (PDF, CDF)</a>
							within the standard deviation error bars (above and below), which are truncated below at
							zero.
							Each simulation is plotted as a separate point.
						</p>
					</section>
					<section>
						<h4>Island Index Case Mutant Mean</h4>
						<p>
							For each island where the mutant is assigned at the simulation run start, print the mean
							mutant fraction after $T$ generations (or when one of the types goes
							extinct&mdash;whichever comes first) over all runs to date.
							In other words, accumulate, given an island, how robustly a starting mutant behaves.
						</p>
					</section>
					<section>
						<h4>Island Mutant Mean</h4>
						<p>
							Accumulate the mutant mean (as in <a href="#visualisation.samplemean">Mutant Mean</a>)
							of each island.
						</p>
					</section>
				</section>
			</section>
			<section id="notation">
				<h2>Notation</h2>
				<p>
					The following notation is used consistently throughout this document and the system itself.
				</p>
				<dl>
					<dt>$\alpha$</dt>
					<dd>
						The outer multiplier for the linear transform of the utility function,
						$\alpha(1 + \delta\pi(x_i, x_{-i})$.
					</dd>
					<dt>$\delta$</dt>
					<dd>
						The inner multiplier for the linear transform of the utility function,
						$\alpha(1 + \delta\pi(x_i, x_{-i})$.
					</dd>
					<dt>$m$</dt>
					<dd>
						For each offspring, the probability of migration.
					</dd>
					<dt>$n$, $n_i$</dt>
					<dd>
						The number of individuals per island
						$n \geq 2$.
						If the islands have a uniform population size, then this number is constant; otherwise, it may be non-uniform
						$n_i$ where $i$ is the fixed index of an island.
					</dd>
					<dt>$N$</dt>
					<dd>
						The total number of islands $N \geq 2$.
					</dd>
					<dt>$\pi$</dt>
					<dd>
						The payoff function.
						This accepts three variables: $x$, the strategy of the current individual; $X$, the sum of all individuals'
						strategies; and $n$ , the number of individuals.
					</dd>
					<dt>$T$</dt>
					<dd>
						The maximum number of generations $T > 0$ for which a simulation run will run.
					</dd>
					<dt>$X$, $x$, $x_i$, $x_{-i}$</dt>
					<dd>
						The real-valued strategy domain, a single strategy in that domain, an individual $i$'s strategy, and all other
						individuals' strategies.
					</dd>
				</dl>
			</section>
			<section>
				<h2 id="bibliography">Bibliography</h2>
				<ul>
					<li id="barnett96">
						R. M. Barnett (1996).
						<i>The Review of Particle Physics</i>, D.54.
						Particle Data Group (PDG).
					</li>
					<li id="knuth98">
						Donald E. Knuth (1998).
						<i>The Art of Computer Programming</i>, volume 2: Seminumerical Algorithms, 3rd edition, p. 232.
						Boston: Addison-Wesley.
					</li>
					<li id="matsumoto98">
						Makato Matsumoto and Takuji Nishimura (1998).
						<q>Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudorandom Number Generator</q>.
						ACM Transactions on Modeling and Computer Simulation 8(1): 3&ndash;30.
					</li>
					<li id="moran62">
						Patrick Alfred Pierce Moran (1962).
						<i>The Statistical Processes of Evolutionary Theory</i>. 
						Oxford: Clarendon Press.
					</li>
					<li id="welford62">
						B. P. Welford (1962).
						<q>Note on a method for calculating corrected sums of squares and products</q>.
						Technometrics 4(3): 419&ndash;420;
					</li>
				</ul>
			</section>
		</article>
		<footer>
			<div>
				&#x00a9; 2014&#8211;2016 <a href="http://www.kcons.eu"><i>k</i>-Consulting</a> 
			</div>
			<div>
				<a title="Download Source" href="snapshots/bmigrate.tgz"><i class="fa fa-gears"></i></a>
				<a title="Archive" href="snapshots"><i class="fa fa-archive"></i></a>
				<a title="GitHub" href="https://github.com/kristapsdz/bmigrate"><i class="fa fa-github"></i></a>
				<a title="Download Mac OS X Binary" href="http://cgi.kcons.eu/bmigrate/bmigrate.app.zip"><i class="fa fa-apple"></i></a>
				<a title="BibTeX Citation" href="bmigrate.bib"><i class="fa fa-bookmark"></i></a>
				<span>Built with <a href="http://kristaps.bsd.lv/sblg">sblg</a> on <a
						href="http://www.openbsd.org">OpenBSD</a></span>
			</div>
		</footer>
	</body>
</html>
