<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
	<!ENTITY % allent SYSTEM "http://www.w3.org/2003/entities/2007/w3centities-f.ent">
	%allent;
]>

<article>
	<articleinfo>
		<title>Simulating the Island Model of Evolutionary Algorithms</title>
		<author>
			<firstname>Kristaps</firstname>
			<surname>Dzonsons</surname>
			<email>kristaps@kcons.eu</email>
		</author>
		<releaseinfo>Version @VERSION@</releaseinfo>
	</articleinfo>
	<sect1 id="intro">
		<title id="intro.title">Introduction</title>
		<para>
			<command>bmigrate</command> is a high-performance scientific application simulating the island model for evolutionary
			algorithms.
			A <firstterm>simulation</firstterm> consists of one or more <firstterm>runs</firstterm>, with each run consisting of a
			finite sequence of <firstterm>generations</firstterm>.
		</para>
		<orderedlist>
			<listitem>
				Initialise a simulation with a fixed number of islands 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
				</inlineequation>, individuals per island
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
				</inlineequation>, migration probability 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
				</inlineequation>, utility function
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
				</inlineequation>, and strategy domain 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>.
			</listitem>
			<listitem>
				Iterate over simulation runs:
				<orderedlist>
					<listitem>
						Initialise all individuals as incumbents, then assign one individual as a mutant.
						Assign a strategy to each individual based on the individual's type, incumbent or mutant.
					</listitem>
					<listitem>
						Iterate over generations:
						<orderedlist>
							<listitem>
								On each island, compute each individual's number of offspring
								(<firstterm>reproduction</firstterm>), which inherit the parent's type.
							</listitem>
							<listitem>
								Assign individuals' offspring to islands (<firstterm>migration</firstterm>).
							</listitem>
							<listitem>
								On each island with immigrants, replace a single inhabitant with a migrant
								(<firstterm>selection</firstterm> and <firstterm>replacement</firstterm>), then
								repeat.
							</listitem>
						</orderedlist>
					</listitem>
					<listitem>
						Terminate the run after a fixed number of generations or when the global mutant or incumbent
						tally reaches zero.
					</listitem>
					<listitem>
						Re-assign the incumbent strategy, mutant strategy, initial mutant's island, then repeat.
					</listitem>
				</orderedlist>
			</listitem>
		</orderedlist>
		<sect2 id="generations">
			<title id="generations.title">Generations</title>
			<para>
				When a generation begins, each island consists of a non-zero number of individuals of either a mutant or
				incumbent type, each with an assigned type-specific strategy.
				A generation proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Compute an individual's reproductive fertility from a Poisson-distributed random number with mean 
					<inlineequation>
						<alt>&alpha;(1 + &delta;&InvisibleTimes;&pi;)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mi>&pi;</mi>
									<mfenced>
										<msub><mi>x</mi><mi>i</mi></msub>
										<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
									</mfenced>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>, 
					where 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
					</inlineequation>
					is a function accepting the individual's strategy
					<inlineequation>
						<alt>x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation> 
					and all other individuals' strategies
					<inlineequation>
						<alt>x_{-i}</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
						</math>
					</inlineequation> on her island.
					For example, on an island with two individuals having strategies 
					<inlineequation>
						<alt>x = 5</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>x</mi><mo>=</mo><mn>5</mn>
						</math>
					</inlineequation> 
					and
					<inlineequation>
						<alt>y = 2</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>y</mi><mo>=</mo><mn>2</mn>
						</math>
					</inlineequation>,
					with the function simply being
					<inlineequation>
						<alt>x_i + x_{-i}&InvisibleTimes;x_i</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<msub><mi>x</mi><mi>i</mi></msub>
							<mo>+</mo>
							<msub><mi>x</mi><mrow><mo>-</mo><mi>i</mi></mrow></msub>
							<mo>&InvisibleTimes;</mo>
							<msub><mi>x</mi><mi>i</mi></msub>
						</math>
					</inlineequation>,
					the first individual's fertility is
					<inlineequation>
						<alt>&alpha;(1 + &delta;15)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>15</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>
					and the second individual's is
					<inlineequation>
						<alt>&alpha;(1 + &delta;12)</alt>
						<math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>&alpha;</mi>
							<mfenced>
								<mrow>
									<mn>1</mn>
									<mo>+</mo>
									<mi>&delta;</mi>
									<mo>&InvisibleTimes;</mo>
									<mn>12</mn>
								</mrow>
							</mfenced>
						</math>
					</inlineequation>.
					Since fertility is Poissonian, it is never negative.
				</listitem>
				<listitem>
					Once each individual's offspring count has been computed, the offspring (which inherit the parent's type)
					migrate to other islands.
					With probability
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
					</inlineequation>,
					an offspring will migrate to a randomly-selected other island.
					Otherwise, the offspring will migrate to the parent's (i.e., the current) island.
				</listitem>
				<listitem>
					Lastly, on each island with a queue of individuals migrated from other islands (or the same island), a single
					randomly-selected individual replaces a single randomly-selected individual on the island.
					If an island has no waiting individuals, nothing happens to that island.
				</listitem>
			</orderedlist>
			<para>
				The tally of mutants and incumbents globally and per-island is recomputed following each generation.
			</para>
		</sect2>
		<sect2>
			<title>Runs</title>
			<para>
				A simulation run begins with all individuals but one being incumbents.
				The mutant type is assigned to a single individual in the total population.
				Each individual is assigned a strategy 
				<inlineequation>
					<alt>x_i</alt>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<msub><mi>x</mi><mi>i</mi></msub>
					</math>
				</inlineequation> 
				based on their type.
				A simulation run proceeds exactly as follows:
			</para>
			<orderedlist>
				<listitem>
					Execute a single generation.
				</listitem>
				<listitem>
					Increment the generation count.
				</listitem>
				<listitem>
					If the generation meets a fixed termination count, stop the run.
					If the global tally of mutants or incumbents reaches zero, stop the run.
					Otherwise, repeat.
				</listitem>
			</orderedlist>
			<para>
				When a simulation run terminates, the fraction of mutants remaining is recorded.
				After accumulating statistics, the run is re-started in its initial configuration with mutant strategy,
				incumbent strategy, and initial mutant island re-assigned.
			</para>
		</sect2>
		<sect2>
			<title>Simulation</title>
			<para>
				Simulations are configured with a number of islands 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
				</inlineequation>,
				individuals per island
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
				</inlineequation>
				(which may be non-uniform), migration probability 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
				</inlineequation>
				(which may be non-uniform and asymmetric), utility function
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
				</inlineequation>, 
				and strategy domain 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>, 
				maximum generation
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
				</inlineequation>, 
				and variables 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&alpha;</mi></mrow></math>
				</inlineequation>, 
				and 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&delta;</mi></mrow></math>
				</inlineequation>
				for transforming utility into the Poisson mean.
				A simulation repeats runs until stopped or paused by the system user.
			</para>
			<para>
				For each run, the incumbent strategy is assigned from a discrete grid over the real-valued strategy domain
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
				</inlineequation>, 
				The grid's boundaries are inclusive of the domain's lower bound, non-inclusive of the domain's upper bound.
				Thus, if 
				<inlineequation>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<mi>X</mi>
						<mo>&isin;</mo>
						<mfenced open="[" close="]">
							<mn>0</mn>
							<mn>1</mn>
						</mfenced>
					</math>
				</inlineequation>
				and the grid has 100 slots, possible strategies will be 0, 0.01, 0.02, ..., 0.99.
				The mutant strategy may be configured in two ways:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						After each simulation run, the mutant strategy is assigned from the next grid position, e.g.,
						from 0.01 to 0.02.
						If the grid position is at the upper bound, it is re-set to the lower bound.
						The incumbent strategy is only re-assigned when the mutant grid position is re-set to the lower
						bound.
						This behaviour ensures that all mutants and incumbents are treated equally over many simulation
						runs.
					</para>
				</listitem>
				<listitem>
					<para>
						The mutant strategy is assigned from a Gaussian distribution with a preconfigured standard
						deviation and the mean set to the incumbent strategy.
						The strategy is redrawn until it falls within a strategy domain that intersects
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>,
						inclusive of the lower bound, non-inclusive of the upper bound.
						The incumbent strategy is re-assigned when the number of mutants for that incumbent have reached
						the number of slots.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				When the incumbent strategy reaches its upper bound, it resets to the lower bound.
				At this point, the initial mutant island is also incremented.
				The initial mutant island will also wrap when it completes the last island.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Installation</title>
		<para>
			You'll need a UNIX machine to use <command>bmigrate</command>.
			The more powerful your machine, the better:
			<command>bmigrate</command> takes advantage of as many processors as possible.
			It has been compiled and run on <ulink url="https://www.apple.com/osx/">Mac OS X</ulink> Snow
			Leopard (10.6) and later, GNU/Linux (<ulink url="https://www.debian.org/">Debian</ulink>), and <ulink
				url="http://www.openbsd.org">OpenBSD</ulink>.
			In theory, the software may be ported to Microsoft Windows as well, but it's unlikely to happen without external
			contribution.
		</para>
		<sect2>
			<title>Binary Installation</title>
			<para>
				Application binaries are available for Mac OS X Lion (10.7) and later.
				To use these, simply download the ZIP file from the website.
				You may need to configure your system to allow downloaded binaries to run.
			</para>
		</sect2>
		<sect2>
			<title>Source Installation</title>
			<para>
				To compile <command>bmigrate</command>, you'll need a number of dependencies.
				First, you'll need a UNIX machine.
				(If you're running on Mac OS X, just use the binary application: it's a real pain in the neck to configure the
				build system for GTK+3 applications.)
			</para>
			<orderedlist>
				<title>Build dependencies</title>
				<listitem>
					<ulink url="https://www.gnu.org/software/make/">gmake</ulink>: GNU Make, for the build system (the
					default <command>make</command> implementation on Mac OS X and GNU/Linux)
				</listitem>
				<listitem>
					<ulink url="http://www.gtk.org/">GTK+3</ulink>: GNOME Toolkit, for the graphics
				</listitem>
				<listitem>
					<ulink url="https://www.gnu.org/software/gsl/">GSL</ulink>: GNU Scientific Library, for mathematical
					functions
				</listitem>
				<listitem>
					<ulink url="http://www.docbook.org/">DocBook v4.5</ulink>: DocBook-XML, for this documentation
				</listitem>
				<listitem>
					<ulink url="http://libbsd.freedesktop.org/wiki/">libbsd</ulink>: BSD libraries (only relevant for
					GNU/Linux systems)
				</listitem>
			</orderedlist>
			<para>
				These are all available as packages for modern UNIX systems.
				If you're downloading and installing any components on you're own, something is wrong.
			</para>
			<para>
				To compile and install the software, simply run the following.
				(This will use <command>pkg-config</command> to locate relevant GNU tools.)
			</para>
			<screen>
% make
% sudo make install
			</screen>
			<para>
				If you're on a BSD system, you may need to invoke <command>gmake</command> if <command>make</command> defaults
				to the BSD implemenation of the same utility.
			</para>
			<para>
				By default, this will install into <filename>/usr/local</filename>.
				To specify an alternative root, pass the <envar>PREFIX</envar> environment variable to the install command.
				Assuming that <filename>$PREFIX/bin</filename> is in your <envar>PATH</envar>, you can then run the system by
				invoking <command>bmigrate</command>.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Mechanics</title>
		<para>
			Being a high-performance scientific application, <command>bmigrate</command> concerns itself a great deal with mechanics
			such as randomness, parallelism, and data-flow.
			This section briefly touches upon these concepts.
		</para>
		<sect2>
			<title>Data-Flow</title>
			<para>
				Data-flow defines how data moves from simulations to graphed output.
				Having data analysed or graphed directly from simulation data would significantly slow down data collection.
				To minimise simulation and interface stalling, data is copied and translated in several stages.
				In general, data is <firstterm>produced</firstterm> by the simulation threads and
				<firstterm>consumed</firstterm>, periodically and in several stages, by the main graphical thread.
			</para>
			<variablelist>
				<varlistentry>
					<term>Hot Storage</term>
					<listitem>
						<para>
							Statistics (e.g., on-line mutant fractions mean per incumbent) are written directly to
							hot storage by simulation threads.
							<firstterm>Hot</firstterm> refers to the high frequency of data access between the simulation
							threads.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Hot Storage Look-aside Buffer</term>
					<listitem>
						<para>
							When the main graphical thread wishes to read fresh data for graphical display, it sets
							a copy flag to copy-out.
							The first simulation thread to see that this flag has been set to copy-out updates the
							flag to copy-pending and copies the hot storage into a look-aside bufffer.
							Hot storage may then continue to be modified by the simulation threads.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Warm Storage</term>
					<listitem>
						<para>
							After copying data from hot storage into a look-aside buffer, the thread that updated
							the copy flag copies the look-aside buffer into warm storage.
							<firstterm>Warm</firstterm> refers to the low frequency of data access between the main
							graphical thread and the copying simulation thread.
							During the copy, the thread also performs more expensive statistical operations (such as
							minimum mutant fraction, or fitting of data) as it copies the data.
							The thread then clears the copy flag.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Cold Storage</term>
					<listitem>
						<para>
							When the main graphical thread detects that the copy flag has been cleared, it copies
							from warm storage into cold storage.
							<firstterm>Cold</firstterm> means that the data is not changed by anybody but the controlling
							(graphical main) thread.
							The main graphical thread also performs some statistical analysis during the copy.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
			<para>
				This sequence ensures a minimum degree of contention between threads.  
				The main graphical thread needs only to wait for the copy flag to be unset before copying the data into its own
				thread of operation.
				The simulation threads need only wait for the look-aside copy, at which point only one thread is used for
				remaining data copy and statistical analysis.
			</para>
		</sect2>
		<sect2>
			<title>Parallelism</title>
			<para>
				Simulations may be executed in parallel if assigned multiple threads during <link linkend="configuration"
					endterm="configuration.title" />.
				By default, each simulation is assigned a single thread.
				Thus, there are several moments when synchronisation between threads occurs to ensure simulations and data-flow
				processes are race-free with minimum contention.
			</para>
			<itemizedlist>
				<listitem>
					Before each simulation, assignment of incumbent and mutant strategies must be synchronised.
					The index for both of these strategies increases monotonically within a critical section (modulo the
					lattice dimensions).
					For Gaussian-distributed mutants, of course, the mutant monotonicity is irrelevant.
				</listitem>
				<listitem>
					After each simulation, the result for a given incumbent must be tallied in a critical section.
					This is required because, in some situations, a single run might take long enough that another processor
					starts running with the same incumbent, with both finishing simultaneously.
				</listitem>
				<listitem>
					When data is copied from hot storage into the look-aside buffer, it is copied within a critical section.
					This prevents partial modification to the data in-copy.
				</listitem>
				<listitem>
					When the main graphical thread requests a data copyout, it does so in a critical section.
					This ensures that only a single simulation thread will perform the copyout, and also that the main
					calling thread won't have its copyout flag unset before all data has been copied.
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Randomness</title>
			<para>
				By default, <command>bmigrate</command> uses the MT19937 (Mersenne-Twister) generator of
				<citation>matsumoto98</citation>.
				This ensures good-quality randomness with a very high period.
				(There is currently no facility in <command>bmigrate</command> for handlng period roll-over.)
			</para>
			<para>
				Each simulation thread is allocated its own randomn number generator.
				Each generator is assigned seed from <function>arc4random</function>, which is implemented differently across
				operating systems.
				This ensures that all threads produce independent random variables.
			</para>
		</sect2>
		<sect2>
			<title>Precision</title>
			<para>
				All floating-point operations of <command>bmigrate</command> use double-precision (type <type>double</type>)
				floating point numbers.
				The statistical algorithms used (see links to algorithm descriptions) provide robust numerical stability.
			</para>
			<para>
				Integral operations (counters) use unsigned 64-bit integers (type <type>uint64_t</type>).
				No checking is done for additive or multiplicative overflow as a simulation with more than
				<inlineequation>
					<alt>2^64</alt>
					<math xmlns="http://www.w3.org/1998/Math/MathML">
						<msup>
							<mn>2</mn>
							<mn>64</mn>
						</msup>
					</math>
				</inlineequation>
				runs is pretty unlikely.
			</para>
		</sect2>
	</sect1>
	<sect1 id="configuration">
		<title id="configuration.title">Configuration</title>
		<para>
			When invoked, <command>bmigrate</command> will pop up a configuration screen.
			You use this to configure and deploy simulations.
			To quit the system, simply press <guibutton>Quit</guibutton>.
			To start a simulation (after entering configuration data), press <guibutton>Simulate</guibutton>.
			The configuration screen will remain open so that you can start subsequent simulations.
		</para>
		<screenshot>
			<graphic fileref="screen-config.png" />
		</screenshot>
		<para>
			Begin by assigning 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
			</inlineequation>, 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
			</inlineequation>,
			and 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
			</inlineequation>.
			This constitutes the environment structure of the game; or in other words, the physical layout of the islands.
			This configuration will improve in the future to allow for non-uniform 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
			</inlineequation>
			and so on.
			For now, it only allows the simplest, uniform structure.
		</para>
		<variablelist>
			<title>Environment Structure</title>
			<varlistentry>
				<term>Uniform</term>
				<listitem>
					<para>
						The simplest configuration of a fixed number of islands 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi></mrow></math>
						</inlineequation>;
						a fixed,
						uniform number of individuals per island 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
						</inlineequation>;
						and a probability
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
						</inlineequation>
						of inter-island migration uniform to all islands.
						The default is 100 individuals across 50 islands.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Variable</term>
				<listitem>
					<para>
						A slightly more complex configuration allowing for non-uniform individuals per island.
						There must be at least two individuals per island.
						The probability 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>
						</inlineequation>
						of inter-island migration must also be applied (it remains uniform per island).
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mapped</term>
				<listitem>
					<para>
						This feature allows for non-uniform inter-island migration and non-uniform population sizes.
						It accepts a <ulink url="http://www.opengeospatial.org/standards/kml/">KML</ulink> map file (as
						created, e.g., with <ulink url="https://www.google.com/earth/">Google Earth</ulink>) populated
						with two or more <code>Placemark</code> sections with appropriate <code>coordinates</code>.
						Inter-island migration is then computed as the normalised inverse-square distance between each
						island.
					</para>
					<para>
						Normalised means that, for each island, the inverse-square distance is computed to all other
						islands.  
						These values are then divided by the sum of all so that each pair of islands is associated with
						a probability.
					</para>
					<para>
						The initial island population defaults to zero unless the string <code>@@population=N@@</code>
						is specified somewhere in the KML text portion within an island's <code>Placemark</code> section.
						The value <code>N</code> must be greater than one.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Next, configure the utility function 
			<inlineequation>
				<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
			</inlineequation>,
			which dictates the reproduction of individuals.
			Note that the utility function is not provided directly to the Poisson generator, but is linearly transformed as
			described in <link linkend="generations" endterm="generations.title" />.
			At this time, only the general case of a continuous function is accepted.
		</para>
		<variablelist>
			<title>Game Configuration</title>
			<varlistentry>
				<term>Continuum</term>
				<listitem>
					<para>
						Configure a utility function accepting individuals' strategies.
						You can either select a preset function or provide one yourself.
					</para>
					<para>
						The utility function 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&pi;</mi></mrow></math>
						</inlineequation>
						accepts the current individual's strategy
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>
						</inlineequation>,
						the sum of all other individuals' strategies
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>
						on the individual's island, and the number of individuals
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>
						</inlineequation>
						on the individual's island.  The function accepts basic binary and
						unary arithmetic operations, nested expressions, the 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>exp</mo></mrow></math>
						</inlineequation>
						function, the
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>sqrt</mo></mrow></math>
						</inlineequation>
						function, and double-precision numbers.
					</para>
					<para>
						You can also change the strategy domain for any individual's strategy, which is inclusive of the
						lower bound, non-inclusive of the upper bound.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Lastly, configure the process machinery itself.
			This involves both the machinery itself and how it relates to hardware (parallelism) and also how payoffs are
			normalised.
		</para>
		<variablelist>
			<title>Process Configuration</title>
			<varlistentry>
				<term>Threads</term>
				<listitem>
					<para>
						The number of threads of execution.
						The maximum number of threads is the number of processors (or cores) of your system.
						You should plan your simulations so as not to oversubscribe your machine, e.g., if you're
						running 4 simulations on a 64-processor machine, you should allocate 16 threads per simulation.
						(This assumes that each simulation is equally time-consuming.)
						Assume that each thread will consume 100% of a processor's resources.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Analysis</term>
				<listitem>
					<para>
						For now, this only accepts the multiple runs option.
						Here you can set the maximum number of generations per simulation run.
						Note that a simulation run may terminate before the maximum if a population type goes extinct.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Parameters</term>
				<listitem>
					<para>
						The linear transform from utility function to Poisson process mean.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Incumbents</term>
				<listitem>
					<para>
						This sets how finely the strategy domain is sliced for assigning incumbents and mutants to
						discrete strategies.
						For example, if this value is 100 (the default), then a strategy domain in the unit interval
						results in strategies of 0, 0.01, 0.02, ..., 0.99.
						A higher number will make a finer mesh, but take more time to process.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Mutants</term>
				<listitem>
					<para>
						Determines how mutants are assigned.
						If discrete, mutants are assigned in sequence from the incumbent grid.
						If Gaussian, mutants are assigned from a Gaussian distribution around the incumbent strategy
						with the given standard deviation.
						The distribution is truncated to the given strategy domain, inclusive of its lower bound,
						non-inclusive of the upper bound.
						This strategy domain must be a superset of the incumbent domain 
						<inlineequation>
							<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi></mrow></math>
						</inlineequation>
						The Box-Muller algorithm is used for producing Gaussian-distributed random numbers.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Fit polynomial</term>
				<listitem>
					<para>
						If you wish to fit incumbents' mean mutant fraction to a polynomial during run-time, you may
						specify the degree of that polynomial here.
						If set to 0, fitting will not be performed.
						If set to non-zero, you may also specify that the fitting be weighed by the variance of each
						incumbent mean mutant fraction.
						The fitting algorithm is the modified Golub-Reinsch SVD algorithm with column scaling.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Name</term>
				<listitem>
					<para>
						A free-form name for the simulation.
						Defaults to the current time.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</sect1>
	<sect1>
		<title>Visualisation</title>
		<para>
			When you've configured a simulation, press <guibutton>Simulate</guibutton> to start the visualisation.
			A window will pop up visualising the simulation in a variety of ways.
			Each window visualises at least one simulation: to compare different simulations, you can drag and drop simulation
			windows into each other.
			On Mac OS X machines, window controls appear in the menu bar.
			On other UNIX machines, you can pop up a menu bar by right-clicking within a simulation window.
		</para>
		<sect2>
			<title>Windows</title>
			<para>
				Each window may have an arbitrary number of simulations and is connected to a particular view of those
				simulations.
				You can choose a new view from the <guimenu>View</guimenu> menu.
				The current view is reflected in the window's title bar.
			</para>
			<sect3 id="samplemean">
				<title id="samplemean.title">Sample Mean</title>
				<para>
					The sample mean graphs incumbents on the x-axis and the mean mutant fraction after
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math>
					</inlineequation>
					generations (or when one of the types goes extinct&mdash;whichever comes
					first) over all runs to date on the y-axis.
					If an incumbent does not have any runs yet, it will display as zero.
					The graph y-maximum will automatically adjust to the highest simulation peak.
				</para>
				<para>
					Each simulation is shown in the legend below the graph.
					The legend shows the simulation colour and name, as well as the number of runs involved in constructing
					the mean.
				</para>
			</sect3>
			<sect3 id="samplemeansigma">
				<title id="samplemeansigma.title">Sample Mean and Sigma</title>
				<para>
					This graph augments the <link linkend="samplemean" endterm="samplemean.title" /> graph with the standard
					deviation above and below each incumbent's mean.
				</para>
				<para>
					The standard deviation is computed from the unbiased sample variance algorithm of
					<citation>knuth98</citation>.
					It shouldn't be confused with the population standard deviation, which is computed over all
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math>
					</inlineequation>
					samples (simulation runs).
					This is an unbiased estimate computed over 
					<inlineequation>
						<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t-1</mi></mrow></math>
					</inlineequation>
					samples.
					See <citation>knuth98</citation> and <citation>welford62</citation> for a discussion.
				</para>
			</sect3>
			<sect3 id="samplemeanfitted">
				<title id="samplemeanfitted.title">Sample Mean and Fitted Polynomial</title>
				<para>
					If a non-zero degree for polynomial fitting was selected at <link linkend="configuration"
						endterm="configuration.title" />, this will show the <link linkend="samplemean"
						endterm="samplemean.title" /> along with that polynomial.
					Otherwise it will only show the <link linkend="samplemean" endterm="samplemean.title" />.
					If the weighted option was selected during <link linkend="configuration" endterm="configuration.title"
						/>, the incumbents' standard deviation will be used as a weight.
				</para>
				<para>
					Unlike the <link linkend="samplemean" endterm="samplemean.title" /> or <link linkend="samplemeansigma"
						endterm="samplemeansigma.title" />, the data for this graph is computed roughly four times per
					second instead of with every run.
					This prevents excessive slow-down.
					The implementations are <function>gsl_multifit_wlinear</function> and
					<function>gsl_multifit_linear</function> for the weighted and non-weighted fitting algorithm,
					respectively, of the <ulink url="https://www.gnu.org/software/gsl/">GNU Scientific Library</ulink>.
					Both are described in the Statistics chapter of <citation>barnett96</citation>.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial (PDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemeanfitted" endterm="samplemeanfitted.title" />
					into an empirical probability distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
				</para>
				<para>
					The minimum value is the first minimum; if multiple subsequent minima are detected (a basin), they are
					ignored.
					Minima are accumulated four times per second.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial (CDF)</title>
				<para>
					Accumulate the minimum value of <link linkend="samplemeanfitted" endterm="samplemeanfitted.title" />
					into an empirical cumulative distribution.
					The mean, mode, and standard deviation (population, not sample) are also displayed.
				</para>
				<para>
					The minimum value is the first minimum; if multiple subsequent minima are detected (a basin), they are
					ignored.
					Minima are accumulated four times per second.
				</para>
			</sect3>
			<sect3>
				<title>Fitted Polynomial Minimum History</title>
				<para>
					Accumulate the last 256 minimum values of <link linkend="samplemeanfitted"
						endterm="samplemeanfitted.title" />.
					The mean and mode are also drawn as solid and dashed horizontal lines, respectively.
				</para>
			</sect3>
		</sect2>
	</sect1>
	<bibliography>
		<title>Bibliography</title>
		<biblioentry>
			<abbrev>knuth98</abbrev>
			<authorgroup>
				<author>
					<firstname>Donald E.</firstname>
					<surname>Knuth</surname>
				</author>
			</authorgroup>
			<pubdate>1998</pubdate>
			<publisher>
				<publishername>Addison-Wesley Publishing Company</publishername>
				<address><city>Boston</city></address>
			</publisher>
			<title>The Art of Computer Programming</title>
			<volumenum>Volume 2</volumenum>
			<subtitle>Seminumerical Algorithms</subtitle>
			<pagenums>232</pagenums>
			<edition>3rd edition</edition>
		</biblioentry>
		<biblioentry>
			<abbrev>welford62</abbrev>
			<author>
				<firstname>B. P.</firstname>
				<surname>Welford</surname>
			</author>
			<pubdate>1962</pubdate>
			<publishername>Technometrics</publishername>
			<issuenum>Number 3</issuenum>
			<volumenum>Volume 4</volumenum>
			<pagenums>419-420</pagenums>
		</biblioentry>
		<biblioentry>
			<abbrev>barnett96</abbrev>
			<editor>
				<firstname>R. M.</firstname>
				<surname>Barnett</surname>
			</editor>
			<pubdate>1996</pubdate>
			<publisher>
				<publishername>Particle Data Group (PDG)</publishername>
			</publisher>
			<title>The Review of Particle Physics D.54</title>
		</biblioentry>
		<biblioentry>
			<abbrev>matsumoto98</abbrev>
			<authorgroup>
				<author>
					<firstname>Makato</firstname>
					<surname>Matsumoto</surname>
				</author>
				<author>
					<firstname>Takuji</firstname>
					<surname>Nishimura</surname>
				</author>
			</authorgroup>
			<title>Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudorandom Number Generator</title>
			<publishername>ACM Transactions on Modeling and Computer Simulation</publishername>
			<volumenum>Volume 8</volumenum>
			<issuenum>Number 1</issuenum>
			<pubdate>January 1998</pubdate>
			<pagenums>3-30</pagenums>
		</biblioentry>
	</bibliography>
</article>
